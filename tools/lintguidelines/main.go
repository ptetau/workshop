package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const generatedTag = "Code generated by scaffold; DO NOT EDIT."

type violation struct {
	File     string `json:"file"`
	Line     int    `json:"line"`
	Column   int    `json:"column"`
	Rule     string `json:"rule"`
	Message  string `json:"message"`
	Severity string `json:"severity"`
}

func main() {
	var (
		root   string
		format string
		strict bool
	)

	flag.StringVar(&root, "root", ".", "repo root")
	flag.StringVar(&format, "format", "text", "output format: text|json")
	flag.BoolVar(&strict, "strict", false, "exit non-zero on violations")
	flag.Parse()

	violations, err := lint(root)
	if err != nil {
		fmt.Fprintln(os.Stderr, "lint:", err)
		os.Exit(1)
	}

	if err := outputViolations(format, violations); err != nil {
		fmt.Fprintln(os.Stderr, "lint:", err)
		os.Exit(1)
	}

	if strict && len(violations) > 0 {
		os.Exit(2)
	}
}

func outputViolations(format string, violations []violation) error {
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	switch format {
	case "json":
		enc := json.NewEncoder(out)
		enc.SetIndent("", "  ")
		return enc.Encode(violations)
	case "text":
		for _, v := range violations {
			fmt.Fprintf(out, "%s:%d:%d [%s] %s\n", v.File, v.Line, v.Column, v.Rule, v.Message)
		}
		if len(violations) == 0 {
			fmt.Fprintln(out, "ok")
		}
		return nil
	default:
		return fmt.Errorf("unknown format %q", format)
	}
}

func lint(root string) ([]violation, error) {
	root = filepath.Clean(root)
	var violations []violation

	concepts, err := listConceptDirs(root)
	if err != nil {
		return nil, err
	}
	conceptSet := map[string]struct{}{}
	for _, c := range concepts {
		conceptSet[c] = struct{}{}
	}

	goFiles, err := listGoFiles(root)
	if err != nil {
		return nil, err
	}

	for _, file := range goFiles {
		if strings.Contains(file, "/tools/") || strings.Contains(file, string(os.PathSeparator)+"tools"+string(os.PathSeparator)) {
			continue
		}
		if isGeneratedFile(file) {
			continue
		}
		v, err := lintGoFile(root, file, conceptSet)
		if err != nil {
			return nil, err
		}
		violations = append(violations, v...)
	}

	routePath := filepath.Join(root, "internal", "adapters", "http", "routes.go")
	if _, err := os.Stat(routePath); err == nil {
		v, err := lintRoutes(root, routePath)
		if err != nil {
			return nil, err
		}
		violations = append(violations, v...)
	}

	violations = append(violations, lintStoragePackages(root, conceptSet)...)

	sort.Slice(violations, func(i, j int) bool {
		if violations[i].File == violations[j].File {
			if violations[i].Line == violations[j].Line {
				return violations[i].Column < violations[j].Column
			}
			return violations[i].Line < violations[j].Line
		}
		return violations[i].File < violations[j].File
	})

	return violations, nil
}

func lintGoFile(root, file string, concepts map[string]struct{}) ([]violation, error) {
	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var violations []violation
	if isConceptFile(root, file) {
		violations = append(violations, lintConceptImports(root, file, parsed, fset, concepts)...)
	}
	if isNamingCheckedFile(root, file) {
		violations = append(violations, lintIdentifiers(file, parsed, fset)...)
	}

	return violations, nil
}

func lintConceptImports(root, file string, parsed *ast.File, fset *token.FileSet, concepts map[string]struct{}) []violation {
	conceptName := conceptFromPath(root, file)
	var violations []violation
	for _, imp := range parsed.Imports {
		path := strings.Trim(imp.Path.Value, `"`)
		if strings.Contains(path, "/internal/domain/") && !strings.HasSuffix(path, "/internal/domain/"+conceptName) {
			violations = append(violations, newViolation(fset, imp.Pos(), file, "concept-coupling", "concepts must not import other concepts"))
		}
		if strings.Contains(path, "/internal/application/") || strings.Contains(path, "/internal/adapters/") {
			violations = append(violations, newViolation(fset, imp.Pos(), file, "concept-coupling", "concepts must not import application or adapters packages"))
		}
	}
	return violations
}

func lintIdentifiers(file string, parsed *ast.File, fset *token.FileSet) []violation {
	var violations []violation
	ast.Inspect(parsed, func(node ast.Node) bool {
		ident, ok := node.(*ast.Ident)
		if !ok || ident == nil {
			return true
		}
		if ident.Name == "_" {
			return true
		}
		if bad := bannedWord(ident.Name); bad != "" {
			violations = append(violations, newViolation(fset, ident.Pos(), file, "naming", fmt.Sprintf("avoid abbreviation %q in identifier %q", bad, ident.Name)))
		}
		return true
	})
	return violations
}

func lintRoutes(root, file string) ([]violation, error) {
	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var violations []violation
	for _, decl := range parsed.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Body == nil || !strings.HasPrefix(fn.Name.Name, "handle") {
			continue
		}
		method := handlerMethod(fn)
		if method == "" {
			continue
		}
		hasProjection, hasOrchestrator := handlerCalls(fn)
		if method == "GET" {
			if !hasProjection {
				violations = append(violations, newViolation(fset, fn.Pos(), file, "route-query", "GET handler must call projections.Query*"))
			}
			if hasOrchestrator {
				violations = append(violations, newViolation(fset, fn.Pos(), file, "route-query", "GET handler must not call orchestrators.Execute*"))
			}
		} else {
			if !hasOrchestrator {
				violations = append(violations, newViolation(fset, fn.Pos(), file, "route-command", method+" handler must call orchestrators.Execute*"))
			}
			if hasProjection {
				violations = append(violations, newViolation(fset, fn.Pos(), file, "route-command", method+" handler must not call projections.Query*"))
			}
		}
	}
	return violations, nil
}

func handlerMethod(fn *ast.FuncDecl) string {
	for _, stmt := range fn.Body.List {
		if ifs, ok := stmt.(*ast.IfStmt); ok {
			if be, ok := ifs.Cond.(*ast.BinaryExpr); ok && be.Op == token.NEQ {
				if sel, ok := be.X.(*ast.SelectorExpr); ok {
					if ident, ok := sel.X.(*ast.Ident); ok && ident.Name == "r" && sel.Sel.Name == "Method" {
						if lit, ok := be.Y.(*ast.BasicLit); ok && lit.Kind == token.STRING {
							return strings.Trim(lit.Value, `"`)
						}
					}
				}
			}
		}
	}
	return ""
}

func handlerCalls(fn *ast.FuncDecl) (bool, bool) {
	hasProjection := false
	hasOrchestrator := false
	ast.Inspect(fn.Body, func(node ast.Node) bool {
		call, ok := node.(*ast.CallExpr)
		if !ok {
			return true
		}
		if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
			if ident, ok := sel.X.(*ast.Ident); ok {
				if ident.Name == "projections" && strings.HasPrefix(sel.Sel.Name, "Query") {
					hasProjection = true
				}
				if ident.Name == "orchestrators" && strings.HasPrefix(sel.Sel.Name, "Execute") {
					hasOrchestrator = true
				}
			}
		}
		return true
	})
	return hasProjection, hasOrchestrator
}

func lintStoragePackages(root string, concepts map[string]struct{}) []violation {
	base := filepath.Join(root, "internal", "adapters", "storage")
	entries, err := os.ReadDir(base)
	if err != nil {
		return nil
	}

	var violations []violation
	for _, entry := range entries {
		if !entry.IsDir() || entry.Name() == "migrations" {
			continue
		}
		concept := entry.Name()
		if _, ok := concepts[concept]; !ok {
			violations = append(violations, violation{
				File:     filepath.Join("internal", "adapters", "storage", concept),
				Line:     1,
				Column:   1,
				Rule:     "storage-isolation",
				Message:  "storage package has no matching concept",
				Severity: "warning",
			})
			continue
		}
		storePath := filepath.Join(base, concept, "store.go")
		fset := token.NewFileSet()
		parsed, err := parser.ParseFile(fset, storePath, nil, parser.ParseComments)
		if err != nil {
			violations = append(violations, violation{
				File:     filepath.Join("internal", "adapters", "storage", concept, "store.go"),
				Line:     1,
				Column:   1,
				Rule:     "storage-isolation",
				Message:  "cannot parse store.go",
				Severity: "warning",
			})
			continue
		}
		if parsed.Name.Name != concept {
			violations = append(violations, newViolation(fset, parsed.Package, storePath, "storage-isolation", "storage package name must match folder name"))
		}
		if !hasStoreInterface(parsed) {
			violations = append(violations, newViolation(fset, parsed.Package, storePath, "storage-isolation", "storage package must define Store interface"))
		}
		for _, imp := range parsed.Imports {
			path := strings.Trim(imp.Path.Value, `"`)
			if strings.Contains(path, "/internal/domain/") && !strings.HasSuffix(path, "/internal/domain/"+concept) {
				violations = append(violations, newViolation(fset, imp.Pos(), storePath, "storage-isolation", "storage must not import other concepts"))
			}
		}
	}
	return violations
}

func hasStoreInterface(parsed *ast.File) bool {
	for _, decl := range parsed.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if ts.Name.Name == "Store" {
				if _, ok := ts.Type.(*ast.InterfaceType); ok {
					return true
				}
			}
		}
	}
	return false
}

func listGoFiles(root string) ([]string, error) {
	var files []string
	err := filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			switch d.Name() {
			case ".git", "vendor", "node_modules", "static", ".scaffold":
				return filepath.SkipDir
			}
			return nil
		}
		if filepath.Ext(path) == ".go" {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

func listConceptDirs(root string) ([]string, error) {
	base := filepath.Join(root, "internal", "domain")
	entries, err := os.ReadDir(base)
	if err != nil {
		return nil, nil
	}
	var concepts []string
	for _, entry := range entries {
		if entry.IsDir() {
			concepts = append(concepts, entry.Name())
		}
	}
	sort.Strings(concepts)
	return concepts, nil
}

func conceptFromPath(root, file string) string {
	rel, err := filepath.Rel(filepath.Join(root, "internal", "domain"), filepath.Dir(file))
	if err != nil {
		return ""
	}
	parts := strings.Split(rel, string(os.PathSeparator))
	if len(parts) > 0 {
		return parts[0]
	}
	return ""
}

func isConceptFile(root, file string) bool {
	base := filepath.Join(root, "internal", "domain")
	return strings.HasPrefix(filepath.Clean(file), filepath.Clean(base)+string(os.PathSeparator))
}

func isNamingCheckedFile(root, file string) bool {
	internal := filepath.Join(root, "internal")
	return strings.HasPrefix(filepath.Clean(file), filepath.Clean(internal)+string(os.PathSeparator))
}

func isGeneratedFile(path string) bool {
	data, err := os.ReadFile(path)
	if err != nil {
		return false
	}
	return strings.Contains(string(data), generatedTag)
}

func bannedWord(name string) string {
	words := splitIdentifier(name)
	for _, word := range words {
		lower := strings.ToLower(word)
		if isAllowedAbbrev(word) {
			continue
		}
		if isBannedAbbrev(lower) {
			return word
		}
	}
	return ""
}

func splitIdentifier(name string) []string {
	var words []string
	var current []rune
	for i, r := range name {
		if r == '_' || r == '-' {
			if len(current) > 0 {
				words = append(words, string(current))
				current = nil
			}
			continue
		}
		if i > 0 && r >= 'A' && r <= 'Z' {
			if len(current) > 0 {
				words = append(words, string(current))
				current = nil
			}
		}
		current = append(current, r)
	}
	if len(current) > 0 {
		words = append(words, string(current))
	}
	return words
}

func isAllowedAbbrev(word string) bool {
	switch word {
	case "ID", "URL", "HTTP", "JSON", "SQL", "UUID", "API":
		return true
	default:
		return false
	}
}

func isBannedAbbrev(word string) bool {
	switch word {
	case "usr", "amt", "cfg", "tmp", "svc":
		return true
	default:
		return false
	}
}

func newViolation(fset *token.FileSet, pos token.Pos, file, rule, message string) violation {
	location := fset.Position(pos)
	path := file
	if location.Filename != "" {
		path = location.Filename
	}
	return violation{
		File:     filepath.ToSlash(path),
		Line:     location.Line,
		Column:   location.Column,
		Rule:     rule,
		Message:  message,
		Severity: "warning",
	}
}
