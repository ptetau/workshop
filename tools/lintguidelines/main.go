package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const generatedTag = "Code generated by scaffold; DO NOT EDIT."

type violation struct {
	File     string `json:"file"`
	Line     int    `json:"line"`
	Column   int    `json:"column"`
	Rule     string `json:"rule"`
	Message  string `json:"message"`
	Severity string `json:"severity"`
}

func main() {
	var (
		root   string
		format string
		strict bool
	)

	flag.StringVar(&root, "root", ".", "repo root")
	flag.StringVar(&format, "format", "text", "output format: text|json")
	flag.BoolVar(&strict, "strict", false, "exit non-zero on violations")
	flag.Parse()

	violations, err := lint(root)
	if err != nil {
		fmt.Fprintln(os.Stderr, "lint:", err)
		os.Exit(1)
	}

	if err := outputViolations(format, violations); err != nil {
		fmt.Fprintln(os.Stderr, "lint:", err)
		os.Exit(1)
	}

	if strict && len(violations) > 0 {
		os.Exit(2)
	}
}

func outputViolations(format string, violations []violation) error {
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	switch format {
	case "json":
		enc := json.NewEncoder(out)
		enc.SetIndent("", "  ")
		return enc.Encode(violations)
	case "text":
		for _, v := range violations {
			fmt.Fprintf(out, "%s:%d:%d [%s] %s\n", v.File, v.Line, v.Column, v.Rule, v.Message)
		}
		if len(violations) == 0 {
			fmt.Fprintln(out, "ok")
		}
		return nil
	default:
		return fmt.Errorf("unknown format %q", format)
	}
}

func lint(root string) ([]violation, error) {
	root = filepath.Clean(root)
	var violations []violation

	concepts, err := listConceptDirs(root)
	if err != nil {
		return nil, err
	}
	conceptSet := map[string]struct{}{}
	for _, c := range concepts {
		conceptSet[c] = struct{}{}
	}

	goFiles, err := listGoFiles(root)
	if err != nil {
		return nil, err
	}

	for _, file := range goFiles {
		if strings.Contains(file, "/tools/") || strings.Contains(file, string(os.PathSeparator)+"tools"+string(os.PathSeparator)) {
			continue
		}
		if isGeneratedFile(file) {
			continue
		}
		v, err := lintGoFile(root, file, conceptSet)
		if err != nil {
			return nil, err
		}
		violations = append(violations, v...)
	}

	routePath := filepath.Join(root, "internal", "adapters", "http", "routes.go")
	if _, err := os.Stat(routePath); err == nil {
		v, err := lintRoutes(root, routePath)
		if err != nil {
			return nil, err
		}
		violations = append(violations, v...)
	}

	violations = append(violations, lintStoragePackages(root, conceptSet)...)
	violations = append(violations, lintWeb(root)...)
	violations = append(violations, lintHandlerFeatureGating(root)...)

	sort.Slice(violations, func(i, j int) bool {
		if violations[i].File == violations[j].File {
			if violations[i].Line == violations[j].Line {
				return violations[i].Column < violations[j].Column
			}
			return violations[i].Line < violations[j].Line
		}
		return violations[i].File < violations[j].File
	})

	return violations, nil
}

func lintGoFile(root, file string, concepts map[string]struct{}) ([]violation, error) {
	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var violations []violation
	if isConceptFile(root, file) {
		violations = append(violations, lintConceptImports(root, file, parsed, fset, concepts)...)
	}
	if isNamingCheckedFile(root, file) {
		violations = append(violations, lintIdentifiers(file, parsed, fset)...)
		violations = append(violations, lintDocumentation(file, parsed, fset)...)
	}

	return violations, nil
}

func lintConceptImports(root, file string, parsed *ast.File, fset *token.FileSet, concepts map[string]struct{}) []violation {
	conceptName := conceptFromPath(root, file)
	var violations []violation
	for _, imp := range parsed.Imports {
		path := strings.Trim(imp.Path.Value, `"`)
		if strings.Contains(path, "/internal/domain/") && !strings.HasSuffix(path, "/internal/domain/"+conceptName) {
			violations = append(violations, newViolation(fset, imp.Pos(), file, "concept-coupling", "concepts must not import other concepts"))
		}
		if strings.Contains(path, "/internal/application/") || strings.Contains(path, "/internal/adapters/") {
			violations = append(violations, newViolation(fset, imp.Pos(), file, "concept-coupling", "concepts must not import application or adapters packages"))
		}
	}
	return violations
}

func lintIdentifiers(file string, parsed *ast.File, fset *token.FileSet) []violation {
	var violations []violation
	ast.Inspect(parsed, func(node ast.Node) bool {
		ident, ok := node.(*ast.Ident)
		if !ok || ident == nil {
			return true
		}
		if ident.Name == "_" {
			return true
		}
		if bad := bannedWord(ident.Name); bad != "" {
			violations = append(violations, newViolation(fset, ident.Pos(), file, "naming", fmt.Sprintf("avoid abbreviation %q in identifier %q", bad, ident.Name)))
		}
		return true
	})
	return violations
}

func lintDocumentation(file string, parsed *ast.File, fset *token.FileSet) []violation {
	var violations []violation
	ast.Inspect(parsed, func(node ast.Node) bool {
		if gen, ok := node.(*ast.GenDecl); ok {
			if gen.Tok == token.TYPE {
				for _, spec := range gen.Specs {
					ts, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					if ast.IsExported(ts.Name.Name) {
						if gen.Doc == nil {
							violations = append(violations, newViolation(fset, ts.Pos(), file, "documentation", "exported type "+ts.Name.Name+" must have comment"))
						}
					}
				}
			}
		}
		if fn, ok := node.(*ast.FuncDecl); ok {
			if ast.IsExported(fn.Name.Name) {
				if fn.Doc == nil {
					violations = append(violations, newViolation(fset, fn.Pos(), file, "documentation", "exported function "+fn.Name.Name+" must have comment"))
				} else if fn.Recv != nil && len(fn.Recv.List) > 0 {
					// Check methods for PRE/POST/INVARIANT tags in doc OR body
					hasTag := false

					// Check header doc
					comment := fn.Doc.Text()
					if strings.Contains(comment, "PRE:") || strings.Contains(comment, "POST:") || strings.Contains(comment, "INVARIANT:") {
						hasTag = true
					}

					// Check body comments
					if !hasTag && fn.Body != nil {
						for _, cg := range parsed.Comments {
							if cg.Pos() > fn.Body.Pos() && cg.End() < fn.Body.End() {
								text := cg.Text()
								if strings.Contains(text, "PRE:") || strings.Contains(text, "POST:") || strings.Contains(text, "INVARIANT:") {
									hasTag = true
									break
								}
							}
						}
					}

					if !hasTag {
						violations = append(violations, newViolation(fset, fn.Pos(), file, "documentation", "method "+fn.Name.Name+" must retain PRE/POST/INVARIANT tags"))
					}
				}
			}
		}
		return true
	})
	return violations
}

func lintRoutes(root, file string) ([]violation, error) {
	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var violations []violation
	for _, decl := range parsed.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Body == nil || !strings.HasPrefix(fn.Name.Name, "handle") {
			continue
		}
		method := handlerMethod(fn)
		if method == "" {
			continue
		}
		hasProjection, hasOrchestrator := handlerCalls(fn)
		if method == "GET" {
			if !hasProjection {
				violations = append(violations, newViolation(fset, fn.Pos(), file, "route-query", "GET handler must call projections.Query*"))
			}
			if hasOrchestrator {
				violations = append(violations, newViolation(fset, fn.Pos(), file, "route-query", "GET handler must not call orchestrators.Execute*"))
			}
		} else {
			if !hasOrchestrator {
				violations = append(violations, newViolation(fset, fn.Pos(), file, "route-command", method+" handler must call orchestrators.Execute*"))
			}
			if hasProjection {
				violations = append(violations, newViolation(fset, fn.Pos(), file, "route-command", method+" handler must not call projections.Query*"))
			}
		}
	}
	return violations, nil
}

func handlerMethod(fn *ast.FuncDecl) string {
	for _, stmt := range fn.Body.List {
		if ifs, ok := stmt.(*ast.IfStmt); ok {
			if be, ok := ifs.Cond.(*ast.BinaryExpr); ok && be.Op == token.NEQ {
				if sel, ok := be.X.(*ast.SelectorExpr); ok {
					if ident, ok := sel.X.(*ast.Ident); ok && ident.Name == "r" && sel.Sel.Name == "Method" {
						if lit, ok := be.Y.(*ast.BasicLit); ok && lit.Kind == token.STRING {
							return strings.Trim(lit.Value, `"`)
						}
					}
				}
			}
		}
	}
	return ""
}

func handlerCalls(fn *ast.FuncDecl) (bool, bool) {
	hasProjection := false
	hasOrchestrator := false
	ast.Inspect(fn.Body, func(node ast.Node) bool {
		call, ok := node.(*ast.CallExpr)
		if !ok {
			return true
		}
		if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
			if ident, ok := sel.X.(*ast.Ident); ok {
				if ident.Name == "projections" && strings.HasPrefix(sel.Sel.Name, "Query") {
					hasProjection = true
				}
				if ident.Name == "orchestrators" && strings.HasPrefix(sel.Sel.Name, "Execute") {
					hasOrchestrator = true
				}
			}
		}
		return true
	})
	return hasProjection, hasOrchestrator
}

func lintStoragePackages(root string, concepts map[string]struct{}) []violation {
	base := filepath.Join(root, "internal", "adapters", "storage")
	entries, err := os.ReadDir(base)
	if err != nil {
		return nil
	}

	var violations []violation
	for _, entry := range entries {
		if !entry.IsDir() || entry.Name() == "migrations" {
			continue
		}
		concept := entry.Name()
		if _, ok := concepts[concept]; !ok {
			violations = append(violations, violation{
				File:     filepath.Join("internal", "adapters", "storage", concept),
				Line:     1,
				Column:   1,
				Rule:     "storage-isolation",
				Message:  "storage package has no matching concept",
				Severity: "warning",
			})
			continue
		}
		storePath := filepath.Join(base, concept, "store.go")
		fset := token.NewFileSet()
		parsed, err := parser.ParseFile(fset, storePath, nil, parser.ParseComments)
		if err != nil {
			violations = append(violations, violation{
				File:     filepath.Join("internal", "adapters", "storage", concept, "store.go"),
				Line:     1,
				Column:   1,
				Rule:     "storage-isolation",
				Message:  "cannot parse store.go",
				Severity: "warning",
			})
			continue
		}
		if parsed.Name.Name != concept {
			violations = append(violations, newViolation(fset, parsed.Package, storePath, "storage-isolation", "storage package name must match folder name"))
		}
		if !hasStoreInterface(parsed) {
			violations = append(violations, newViolation(fset, parsed.Package, storePath, "storage-isolation", "storage package must define Store interface"))
		}
		for _, imp := range parsed.Imports {
			path := strings.Trim(imp.Path.Value, `"`)
			if strings.Contains(path, "/internal/domain/") && !strings.HasSuffix(path, "/internal/domain/"+concept) {
				violations = append(violations, newViolation(fset, imp.Pos(), storePath, "storage-isolation", "storage must not import other concepts"))
			}
		}
	}
	return violations
}

func lintWeb(root string) []violation {
	webPath := filepath.Join(root, "internal", "adapters", "http", "web.go")
	if _, err := os.Stat(webPath); err != nil {
		return nil // Missing web.go is acceptable (maybe no UI layer)
	}

	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, webPath, nil, parser.ParseComments)
	if err != nil {
		return []violation{{
			File:     webPath,
			Line:     1,
			Column:   1,
			Rule:     "web-security",
			Message:  "cannot parse web.go",
			Severity: "warning",
		}}
	}

	var violations []violation
	// Look for NewMux
	for _, decl := range parsed.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Name.Name != "NewMux" {
			continue
		}

		// Check Body for security calls
		hasCSRF := false
		hasHeaders := false

		ast.Inspect(fn.Body, func(node ast.Node) bool {
			if sel, ok := node.(*ast.SelectorExpr); ok {
				if ident, ok := sel.X.(*ast.Ident); ok && ident.Name == "middleware" {
					if strings.Contains(sel.Sel.Name, "CSRF") {
						hasCSRF = true
					}
					if strings.Contains(sel.Sel.Name, "SecurityHeaders") {
						hasHeaders = true
					}
				}
			}
			return true
		})

		if !hasCSRF {
			violations = append(violations, newViolation(fset, fn.Pos(), webPath, "web-security", "NewMux must apply middleware.CSRF"))
		}
		if !hasHeaders {
			violations = append(violations, newViolation(fset, fn.Pos(), webPath, "web-security", "NewMux must apply middleware.SecurityHeaders"))
		}
	}
	return violations
}

// lintHandlerFeatureGating checks that every handlers_*.go file (excluding
// handlers.go itself, which defines the helpers) contains at least one call
// to requireFeatureAPI or requireFeaturePage.
// This enforces the guideline that every new feature handler file must be
// gated by a feature flag.
func lintHandlerFeatureGating(root string) []violation {
	httpDir := filepath.Join(root, "internal", "adapters", "http")
	entries, err := os.ReadDir(httpDir)
	if err != nil {
		return nil
	}

	var violations []violation
	for _, entry := range entries {
		name := entry.Name()
		// Only check handlers_*.go files, not handlers.go (which defines the helpers)
		// and not test files.
		if entry.IsDir() {
			continue
		}
		if !strings.HasPrefix(name, "handlers_") || strings.HasSuffix(name, "_test.go") {
			continue
		}
		if !strings.HasSuffix(name, ".go") {
			continue
		}

		filePath := filepath.Join(httpDir, name)
		fset := token.NewFileSet()
		parsed, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
		if err != nil {
			continue
		}

		// Check if the file defines any handler functions (func handle*)
		hasHandlers := false
		hasFeatureGate := false

		ast.Inspect(parsed, func(node ast.Node) bool {
			fn, ok := node.(*ast.FuncDecl)
			if !ok {
				return true
			}
			if strings.HasPrefix(fn.Name.Name, "handle") {
				hasHandlers = true
			}
			// Look for calls to requireFeatureAPI or requireFeaturePage
			if fn.Body != nil {
				ast.Inspect(fn.Body, func(inner ast.Node) bool {
					call, ok := inner.(*ast.CallExpr)
					if !ok {
						return true
					}
					if ident, ok := call.Fun.(*ast.Ident); ok {
						if ident.Name == "requireFeatureAPI" || ident.Name == "requireFeaturePage" {
							hasFeatureGate = true
						}
					}
					return true
				})
			}
			return true
		})

		if hasHandlers && !hasFeatureGate {
			violations = append(violations, violation{
				File:     filepath.ToSlash(filePath),
				Line:     1,
				Column:   1,
				Rule:     "feature-flag",
				Message:  name + ": handler file must call requireFeatureAPI or requireFeaturePage to gate access",
				Severity: "warning",
			})
		}
	}
	return violations
}

func hasStoreInterface(parsed *ast.File) bool {
	for _, decl := range parsed.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			name := ts.Name.Name
			if name == "Store" || strings.HasSuffix(name, "Store") {
				if _, ok := ts.Type.(*ast.InterfaceType); ok {
					return true
				}
			}
		}
	}
	return false
}

func listGoFiles(root string) ([]string, error) {
	var files []string
	err := filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			switch d.Name() {
			case ".git", "vendor", "node_modules", "static", ".scaffold":
				return filepath.SkipDir
			}
			return nil
		}
		if filepath.Ext(path) == ".go" {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

func listConceptDirs(root string) ([]string, error) {
	base := filepath.Join(root, "internal", "domain")
	entries, err := os.ReadDir(base)
	if err != nil {
		return nil, nil
	}
	var concepts []string
	for _, entry := range entries {
		if entry.IsDir() {
			concepts = append(concepts, entry.Name())
		}
	}
	sort.Strings(concepts)
	return concepts, nil
}

func conceptFromPath(root, file string) string {
	rel, err := filepath.Rel(filepath.Join(root, "internal", "domain"), filepath.Dir(file))
	if err != nil {
		return ""
	}
	parts := strings.Split(rel, string(os.PathSeparator))
	if len(parts) > 0 {
		return parts[0]
	}
	return ""
}

func isConceptFile(root, file string) bool {
	base := filepath.Join(root, "internal", "domain")
	return strings.HasPrefix(filepath.Clean(file), filepath.Clean(base)+string(os.PathSeparator))
}

func isNamingCheckedFile(root, file string) bool {
	internal := filepath.Join(root, "internal")
	return strings.HasPrefix(filepath.Clean(file), filepath.Clean(internal)+string(os.PathSeparator))
}

func isGeneratedFile(path string) bool {
	data, err := os.ReadFile(path)
	if err != nil {
		return false
	}
	return strings.Contains(string(data), generatedTag)
}

func bannedWord(name string) string {
	words := splitIdentifier(name)
	for _, word := range words {
		lower := strings.ToLower(word)
		if isAllowedAbbrev(word) {
			continue
		}
		if isBannedAbbrev(lower) {
			return word
		}
	}
	return ""
}

func splitIdentifier(name string) []string {
	var words []string
	var current []rune
	for i, r := range name {
		if r == '_' || r == '-' {
			if len(current) > 0 {
				words = append(words, string(current))
				current = nil
			}
			continue
		}
		if i > 0 && r >= 'A' && r <= 'Z' {
			if len(current) > 0 {
				words = append(words, string(current))
				current = nil
			}
		}
		current = append(current, r)
	}
	if len(current) > 0 {
		words = append(words, string(current))
	}
	return words
}

func isAllowedAbbrev(word string) bool {
	switch word {
	case "ID", "URL", "HTTP", "JSON", "SQL", "UUID", "API":
		return true
	default:
		return false
	}
}

func isBannedAbbrev(word string) bool {
	switch word {
	case "usr", "amt", "cfg", "tmp", "svc":
		return true
	default:
		return false
	}
}

func newViolation(fset *token.FileSet, pos token.Pos, file, rule, message string) violation {
	location := fset.Position(pos)
	path := file
	if location.Filename != "" {
		path = location.Filename
	}
	return violation{
		File:     filepath.ToSlash(path),
		Line:     location.Line,
		Column:   location.Column,
		Rule:     rule,
		Message:  message,
		Severity: "warning",
	}
}
