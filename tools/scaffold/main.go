package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
	"unicode"
)

const (
	statePath          = ".scaffold/state.json"
	routesGeneratedTag = "Code generated by scaffold; DO NOT EDIT."
)

type field struct {
	Name        string `json:"name"`
	Type        string `json:"type"`
	Description string `json:"description,omitempty"`
}

type method struct {
	Name          string `json:"name"`
	Description   string `json:"description,omitempty"`
	Invariant     string `json:"invariant,omitempty"`
	PreCondition  string `json:"pre_condition,omitempty"`
	PostCondition string `json:"post_condition,omitempty"`
}

type concept struct {
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Fields      []field  `json:"fields"`
	Methods     []method `json:"methods"`
}

type orchestrator struct {
	Name        string  `json:"name"`
	Description string  `json:"description,omitempty"`
	Params      []field `json:"params"`
}

type projection struct {
	Name        string  `json:"name"`
	Description string  `json:"description,omitempty"`
	Query       []field `json:"query"`
	Result      []field `json:"result"`
}

type route struct {
	Method string `json:"method"`
	Path   string `json:"path"`
	Target string `json:"target"`
}

type state struct {
	Version       int                     `json:"version"`
	Concepts      map[string]concept      `json:"concepts"`
	Orchestrators map[string]orchestrator `json:"orchestrators"`
	Projections   map[string]projection   `json:"projections"`
	Routes        []route                 `json:"routes"`
}

type multiFlag []string

func (m *multiFlag) String() string { return strings.Join(*m, ",") }
func (m *multiFlag) Set(value string) error {
	*m = append(*m, value)
	return nil
}

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(2)
	}

	switch os.Args[1] {
	case "init":
		if err := runInit(os.Args[2:]); err != nil {
			fmt.Fprintln(os.Stderr, "scaffold:", err)
			os.Exit(1)
		}
	default:
		printUsage()
		os.Exit(2)
	}
}

func printUsage() {
	fmt.Println("usage: scaffold init [flags]")
	fmt.Println("flags:")
	fmt.Println("  --root Path (output directory)")
	fmt.Println("  --module Path (module path)")
	fmt.Println("  --concept Name")
	fmt.Println("  --field Concept:Field:Type")
	fmt.Println("  --method Concept:Method")
	fmt.Println("  --orchestrator Name")
	fmt.Println("  --param Orchestrator:Param:Type")
	fmt.Println("  --projection Name")
	fmt.Println("  --query Projection:Field:Type")
	fmt.Println("  --result Projection:Field:Type")
	fmt.Println("  --route Method:Path:Target")
	fmt.Println("  --description Concept:Description")
	fmt.Println("  --field-doc Concept:Field:Description")
	fmt.Println("  --method-doc Concept:Method:Description")
	fmt.Println("  --pre Concept:Method:PreCondition")
	fmt.Println("  --post Concept:Method:PostCondition")
	fmt.Println("  --invariant Concept:Method:Invariant")
	fmt.Println("  --orchestrator-doc Orchestrator:Description")
	fmt.Println("  --param-doc Orchestrator:Param:Description")
	fmt.Println("  --projection-doc Projection:Description")
	fmt.Println("  --query-doc Projection:Query:Description")
	fmt.Println("  --result-doc Projection:Result:Description")
	fmt.Println("  --force (overwrite existing files)")
}

func runInit(args []string) error {
	var (
		root              string
		module            string
		conceptFlags      multiFlag
		fieldFlags        multiFlag
		methodFlags       multiFlag
		orchestratorFlags multiFlag
		paramFlags        multiFlag
		projectionFlags   multiFlag
		queryFlags        multiFlag
		resultFlags       multiFlag
		routeFlags        multiFlag
		descriptionFlags  multiFlag
		invariantFlags    multiFlag
		force             bool
	)

	fs := flag.NewFlagSet("init", flag.ContinueOnError)
	fs.SetOutput(os.Stderr)
	fs.StringVar(&root, "root", ".", "output directory")
	fs.StringVar(&module, "module", "", "module path")
	fs.Var(&conceptFlags, "concept", "concept name")
	fs.Var(&fieldFlags, "field", "concept field: Concept:Field:Type")
	fs.Var(&methodFlags, "method", "concept method: Concept:Method")
	fs.Var(&orchestratorFlags, "orchestrator", "orchestrator name")
	fs.Var(&paramFlags, "param", "orchestrator param: Orchestrator:Param:Type")
	fs.Var(&projectionFlags, "projection", "projection name")
	fs.Var(&queryFlags, "query", "projection query field: Projection:Field:Type")
	fs.Var(&resultFlags, "result", "projection result field: Projection:Field:Type")
	fs.Var(&routeFlags, "route", "route: Method:Path:Target")
	fs.Var(&descriptionFlags, "description", "concept description: Concept:Description")
	fs.Var(&invariantFlags, "invariant", "method invariant: Concept:Method:Invariant")

	var (
		fieldDocFlags        multiFlag
		methodDocFlags       multiFlag
		preFlags             multiFlag
		postFlags            multiFlag
		orchestratorDocFlags multiFlag
		paramDocFlags        multiFlag
		projectionDocFlags   multiFlag
		queryDocFlags        multiFlag
		resultDocFlags       multiFlag
	)

	fs.Var(&fieldDocFlags, "field-doc", "field doc: Concept:Field:Description")
	fs.Var(&methodDocFlags, "method-doc", "method doc: Concept:Method:Description")
	fs.Var(&preFlags, "pre", "method pre: Concept:Method:PreCondition")
	fs.Var(&postFlags, "post", "method post: Concept:Method:PostCondition")
	fs.Var(&orchestratorDocFlags, "orchestrator-doc", "orchestrator doc: Orchestrator:Description")
	fs.Var(&paramDocFlags, "param-doc", "param doc: Orchestrator:Param:Description")
	fs.Var(&projectionDocFlags, "projection-doc", "projection doc: Projection:Description")
	fs.Var(&queryDocFlags, "query-doc", "query doc: Projection:Query:Description")
	fs.Var(&resultDocFlags, "result-doc", "result doc: Projection:Query:Description")
	fs.BoolVar(&force, "force", false, "overwrite existing files")
	if err := fs.Parse(args); err != nil {
		return err
	}

	if root == "" {
		root = "."
	}
	if err := os.MkdirAll(root, 0o755); err != nil {
		return err
	}
	if err := os.Chdir(root); err != nil {
		return err
	}

	moduleName, err := resolveModuleName(module)
	if err != nil {
		return err
	}

	current, err := loadState()
	if err != nil {
		return err
	}

	if err := ensureBaseLayout(moduleName, force); err != nil {
		return err
	}

	desired := buildDesiredState(
		conceptFlags, fieldFlags, methodFlags, orchestratorFlags, paramFlags, projectionFlags, queryFlags, resultFlags, routeFlags, descriptionFlags, invariantFlags,
		fieldDocFlags, methodDocFlags, preFlags, postFlags, orchestratorDocFlags, paramDocFlags, projectionDocFlags, queryDocFlags, resultDocFlags,
	)
	updated, err := applyState(moduleName, current, desired, force)
	if err != nil {
		return err
	}

	if err := writeState(updated); err != nil {
		return err
	}

	return nil
}

func ensureBaseLayout(moduleName string, force bool) error {
	dirs := []string{
		"internal/domain",
		"internal/application",
		"internal/application/orchestrators",
		"internal/application/projections",
		"internal/adapters/http",
		"internal/adapters/storage",
		"internal/adapters/storage/migrations",
		"cmd/server",
		"static",
	}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return err
		}
	}

	if err := writeFileIfMissing("go.mod", goModTemplate(moduleName), force); err != nil {
		return err
	}
	if err := writeFileIfMissing("cmd/server/main.go", serverMainTemplate(moduleName), force); err != nil {
		return err
	}
	if err := writeFileIfMissing("internal/adapters/http/web.go", webTemplate(moduleName), force); err != nil {
		return err
	}
	if err := writeFileIfMissing("internal/domain/README.md", "# Domain (Concepts)\n\nPlace concept state and methods here.\n", force); err != nil {
		return err
	}
	if err := writeFileIfMissing("internal/application/README.md", "# Application (Orchestrators + Projections)\n\nPlace orchestrators and projections here.\n", force); err != nil {
		return err
	}
	if err := writeGeneratedFile("internal/adapters/http/routes.go", routesTemplate(moduleName, nil), force); err != nil {
		return err
	}
	if err := writeFileIfMissing("internal/adapters/storage/db.go", dbTemplate(moduleName), force); err != nil {
		return err
	}

	// Middleware
	if err := writeFileIfMissing("internal/adapters/http/middleware/middleware.go", middlewareTemplate(moduleName), force); err != nil {
		return err
	}

	// HTML templates
	if err := writeFileIfMissing("internal/adapters/http/templates/layout.html", layoutHTMLTemplate(), force); err != nil {
		return err
	}

	return nil
}

func buildDesiredState(
	concepts, fields, methods, orchestrators, params, projections, queries, results, routes, descriptions, invariants,
	fieldDocs, methodDocs, pres, posts, orchDocs, paramDocs, projDocs, queryDocs, resultDocs multiFlag,
) state {
	desired := state{
		Version:       1,
		Concepts:      map[string]concept{},
		Orchestrators: map[string]orchestrator{},
		Projections:   map[string]projection{},
		Routes:        []route{},
	}

	for _, c := range concepts {
		name := strings.TrimSpace(c)
		if name == "" {
			continue
		}
		desired.Concepts[name] = concept{Name: name}
	}
	for _, f := range fields {
		conceptName, fieldName, fieldType, err := splitTriple(f)
		if err != nil {
			fmt.Fprintf(os.Stderr, "skipping field %q: %v\n", f, err)
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		c.Fields = append(c.Fields, field{Name: fieldName, Type: fieldType})
		desired.Concepts[conceptName] = c
	}
	for _, fd := range fieldDocs {
		conceptName, fieldName, desc, err := splitTriple(fd)
		if err != nil {
			fmt.Fprintf(os.Stderr, "skipping field-doc %q: %v\n", fd, err)
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		for i, f := range c.Fields {
			if f.Name == fieldName {
				c.Fields[i].Description = desc
				break
			}
		}
		desired.Concepts[conceptName] = c
	}
	for _, m := range methods {
		conceptName, methodName, err := splitPair(m)
		if err != nil {
			fmt.Fprintf(os.Stderr, "skipping method %q: %v\n", m, err)
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		found := false
		for _, existing := range c.Methods {
			if existing.Name == methodName {
				found = true
				break
			}
		}
		if !found {
			c.Methods = append(c.Methods, method{Name: methodName})
		}
		desired.Concepts[conceptName] = c
	}
	for _, d := range descriptions {
		conceptName, desc, err := splitPair(d)
		if err != nil {
			fmt.Fprintf(os.Stderr, "skipping description %q: %v\n", d, err)
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		c.Description = desc
		desired.Concepts[conceptName] = c
	}
	for _, md := range methodDocs {
		conceptName, methodName, desc, err := splitTriple(md)
		if err != nil {
			fmt.Fprintf(os.Stderr, "skipping method-doc %q: %v\n", md, err)
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		found := false
		for i, m := range c.Methods {
			if m.Name == methodName {
				c.Methods[i].Description = desc
				found = true
				break
			}
		}
		if !found {
			fmt.Fprintf(os.Stderr, "method-doc provided for unknown method %q in %q\n", methodName, conceptName)
		}
		desired.Concepts[conceptName] = c
	}
	for _, p := range pres {
		conceptName, methodName, cond, err := splitTriple(p)
		if err != nil {
			fmt.Fprintf(os.Stderr, "skipping pre %q: %v\n", p, err)
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		for i, m := range c.Methods {
			if m.Name == methodName {
				c.Methods[i].PreCondition = cond
				break
			}
		}
		desired.Concepts[conceptName] = c
	}
	for _, p := range posts {
		conceptName, methodName, cond, err := splitTriple(p)
		if err != nil {
			fmt.Fprintf(os.Stderr, "skipping post %q: %v\n", p, err)
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		for i, m := range c.Methods {
			if m.Name == methodName {
				c.Methods[i].PostCondition = cond
				break
			}
		}
		desired.Concepts[conceptName] = c
	}
	for _, inv := range invariants {
		conceptName, methodName, invariant, err := splitTriple(inv)
		if err != nil {
			fmt.Fprintf(os.Stderr, "skipping invariant %q: %v\n", inv, err)
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		for i, existing := range c.Methods {
			if existing.Name == methodName {
				c.Methods[i].Invariant = invariant
				break
			}
		}
		desired.Concepts[conceptName] = c
	}
	for _, o := range orchestrators {
		name := strings.TrimSpace(o)
		if name == "" {
			continue
		}
		desired.Orchestrators[name] = orchestrator{Name: name}
	}
	for _, od := range orchDocs {
		name, desc, err := splitPair(od)
		if err != nil {
			continue
		}
		o := desired.Orchestrators[name]
		o.Name = name
		o.Description = desc
		desired.Orchestrators[name] = o
	}
	for _, p := range params {
		orchName, fieldName, fieldType, err := splitTriple(p)
		if err != nil {
			continue
		}
		o := desired.Orchestrators[orchName]
		o.Name = orchName
		o.Params = append(o.Params, field{Name: fieldName, Type: fieldType})
		desired.Orchestrators[orchName] = o
	}
	for _, pd := range paramDocs {
		orchName, paramName, desc, err := splitTriple(pd)
		if err != nil {
			continue
		}
		o := desired.Orchestrators[orchName]
		o.Name = orchName
		for i, p := range o.Params {
			if p.Name == paramName {
				o.Params[i].Description = desc
				break
			}
		}
		desired.Orchestrators[orchName] = o
	}
	for _, p := range projections {
		name := strings.TrimSpace(p)
		if name == "" {
			continue
		}
		desired.Projections[name] = projection{Name: name}
	}
	for _, pd := range projDocs {
		name, desc, err := splitPair(pd)
		if err != nil {
			continue
		}
		p := desired.Projections[name]
		p.Name = name
		p.Description = desc
		desired.Projections[name] = p
	}
	for _, q := range queries {
		projName, fieldName, fieldType, err := splitTriple(q)
		if err != nil {
			continue
		}
		p := desired.Projections[projName]
		p.Name = projName
		p.Query = append(p.Query, field{Name: fieldName, Type: fieldType})
		desired.Projections[projName] = p
	}
	for _, qd := range queryDocs {
		projName, fieldName, desc, err := splitTriple(qd)
		if err != nil {
			continue
		}
		p := desired.Projections[projName]
		p.Name = projName
		for i, f := range p.Query {
			if f.Name == fieldName {
				p.Query[i].Description = desc
				break
			}
		}
		desired.Projections[projName] = p
	}
	for _, r := range results {
		projName, fieldName, fieldType, err := splitTriple(r)
		if err != nil {
			continue
		}
		p := desired.Projections[projName]
		p.Name = projName
		p.Result = append(p.Result, field{Name: fieldName, Type: fieldType})
		desired.Projections[projName] = p
	}
	for _, rd := range resultDocs {
		projName, fieldName, desc, err := splitTriple(rd)
		if err != nil {
			continue
		}
		p := desired.Projections[projName]
		p.Name = projName
		for i, f := range p.Result {
			if f.Name == fieldName {
				p.Result[i].Description = desc
				break
			}
		}
		desired.Projections[projName] = p
	}
	for _, r := range routes {
		method, path, target, err := splitTriple(r)
		if err != nil {
			continue
		}
		desired.Routes = append(desired.Routes, route{Method: strings.ToUpper(method), Path: path, Target: target})
	}

	return desired
}

func applyState(moduleName string, current state, desired state, force bool) (state, error) {
	if current.Version == 0 {
		current = state{
			Version:       1,
			Concepts:      map[string]concept{},
			Orchestrators: map[string]orchestrator{},
			Projections:   map[string]projection{},
			Routes:        []route{},
		}
	}

	processedConcepts := map[string]bool{}
	for name, c := range desired.Concepts {
		currentConcept := current.Concepts[name]
		merged := mergeConcept(currentConcept, c)
		current.Concepts[name] = merged

		if err := scaffoldConcept(moduleName, merged, currentConcept, force); err != nil {
			return current, err
		}
		processedConcepts[name] = true
	}

	for name, c := range current.Concepts {
		if processedConcepts[name] {
			continue
		}
		if err := scaffoldConcept(moduleName, c, c, force); err != nil {
			return current, err
		}
	}

	for name, o := range desired.Orchestrators {
		currentOrch := current.Orchestrators[name]
		merged := mergeOrchestrator(currentOrch, o)
		current.Orchestrators[name] = merged

		if err := scaffoldOrchestrator(merged, force); err != nil {
			return current, err
		}
	}

	for name, p := range desired.Projections {
		currentProj := current.Projections[name]
		merged := mergeProjection(currentProj, p)
		current.Projections[name] = merged

		if err := scaffoldProjection(merged, force); err != nil {
			return current, err
		}
	}

	if len(desired.Routes) > 0 {
		current.Routes = mergeRoutes(current.Routes, desired.Routes)
		if err := scaffoldRoutes(moduleName, current.Routes, force); err != nil {
			return current, err
		}
	}

	return current, nil
}

func scaffoldConcept(moduleName string, c concept, previous concept, force bool) error {
	normalizeConcept(&c)

	conceptDir := filepath.Join("internal/domain", toSnakeCase(c.Name))
	if err := os.MkdirAll(conceptDir, 0o755); err != nil {
		return err
	}

	modelPath := filepath.Join(conceptDir, "model.go")
	if _, err := os.Stat(modelPath); err == nil {
		// Update existing
		src, err := os.ReadFile(modelPath)
		if err != nil {
			return err
		}
		updated, err := UpdateStructFields(src, c.Name, c.Fields)
		if err != nil {
			return fmt.Errorf("failed to update struct: %w", err)
		}
		if err := os.WriteFile(modelPath, updated, 0644); err != nil {
			return err
		}
	} else {
		// Create new
		if err := writeFileIfMissing(modelPath, conceptTemplate(c), force); err != nil {
			return err
		}
	}

	storeDir := filepath.Join("internal/adapters/storage", toSnakeCase(c.Name))
	if err := os.MkdirAll(storeDir, 0o755); err != nil {
		return err
	}
	storePath := filepath.Join(storeDir, "store.go")
	if err := writeFileIfMissing(storePath, storageTemplate(moduleName, c), force); err != nil {
		return err
	}

	if err := writeFileIfMissing(filepath.Join(storeDir, "sqlite_store.go"), sqliteStoreTemplate(moduleName, c), force); err != nil {
		return err
	}

	if err := writeMigration(c, previous); err != nil {
		return err
	}

	return nil
}

func scaffoldOrchestrator(o orchestrator, force bool) error {
	normalizeFields(&o.Params)
	path := filepath.Join("internal/application/orchestrators", toSnakeCase(o.Name)+".go")

	if _, err := os.Stat(path); err == nil {
		// Update Go Struct
		src, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		updated, err := UpdateStructFields(src, o.Name+"Input", o.Params)
		if err != nil {
			return fmt.Errorf("failed to update orchestrator input: %w", err)
		}
		if err := os.WriteFile(path, updated, 0644); err != nil {
			return err
		}
	} else {
		if err := writeFileIfMissing(path, orchestratorTemplate(o), force); err != nil {
			return err
		}
	}

	// UI Form
	formPath := filepath.Join("internal/adapters/http/templates", "form_"+toSnakeCase(o.Name)+".html")
	if _, err := os.Stat(formPath); err == nil {
		// Update HTML
		src, err := os.ReadFile(formPath)
		if err != nil {
			return err
		}
		updated, err := UpdateHTMLForm(string(src), o.Params)
		if err != nil {
			return fmt.Errorf("failed to update form html: %w", err)
		}
		if err := os.WriteFile(formPath, []byte(updated), 0644); err != nil {
			return err
		}
	} else {
		return writeFileIfMissing(formPath, formHTMLTemplate(o), force)
	}
	return nil
}

func scaffoldProjection(p projection, force bool) error {
	normalizeFields(&p.Query)
	normalizeFields(&p.Result)
	path := filepath.Join("internal/application/projections", toSnakeCase(p.Name)+".go")

	if _, err := os.Stat(path); err == nil {
		// Update Go Structs
		src, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		// Update Query Struct
		updated, err := UpdateStructFields(src, p.Name+"Query", p.Query)
		if err != nil {
			return fmt.Errorf("failed to update projection query: %w", err)
		}
		// Update Result Struct
		updated, err = UpdateStructFields(updated, p.Name+"Result", p.Result)
		if err != nil {
			return fmt.Errorf("failed to update projection result: %w", err)
		}
		if err := os.WriteFile(path, updated, 0644); err != nil {
			return err
		}
	} else {
		if err := writeFileIfMissing(path, projectionTemplate(p), force); err != nil {
			return err
		}
	}

	// UI View
	viewPath := filepath.Join("internal/adapters/http/templates", toSnakeCase(p.Name)+".html")
	if _, err := os.Stat(viewPath); err == nil {
		// Update HTML
		src, err := os.ReadFile(viewPath)
		if err != nil {
			return err
		}
		updated, err := UpdateHTMLView(string(src), p.Result)
		if err != nil {
			return fmt.Errorf("failed to update view html: %w", err)
		}
		if err := os.WriteFile(viewPath, []byte(updated), 0644); err != nil {
			return err
		}
	} else {
		return writeFileIfMissing(viewPath, viewHTMLTemplate(p), force)
	}
	return nil
}

func scaffoldRoutes(moduleName string, routes []route, force bool) error {
	sort.Slice(routes, func(i, j int) bool {
		if routes[i].Path == routes[j].Path {
			return routes[i].Method < routes[j].Method
		}
		return routes[i].Path < routes[j].Path
	})
	content := routesTemplate(moduleName, routes)
	return writeGeneratedFile("internal/adapters/http/routes.go", content, force)
}

func writeMigration(current concept, previous concept) error {
	prevIsNew := len(previous.Fields) == 0

	normalizeConcept(&current)
	normalizeConcept(&previous)

	if prevIsNew {
		return writeCreateMigration(current)
	}

	newFields := diffFields(previous.Fields, current.Fields)
	if len(newFields) == 0 {
		return nil
	}

	return writeAlterMigration(current.Name, newFields)
}

func writeCreateMigration(c concept) error {
	path := filepath.Join("internal/adapters/storage/migrations", timestampedName("create", c.Name)+".sql")
	if _, err := os.Stat(path); err == nil {
		return nil
	}

	var columns []string
	for _, f := range c.Fields {
		columns = append(columns, fmt.Sprintf("  %s %s", toSnakeCase(f.Name), sqlType(f.Type)))
	}
	content := fmt.Sprintf("CREATE TABLE %s (\n%s\n);\n", toSnakeCase(c.Name), strings.Join(columns, ",\n"))
	return os.WriteFile(path, []byte(content), 0o644)
}

func writeAlterMigration(conceptName string, fields []field) error {
	path := filepath.Join("internal/adapters/storage/migrations", timestampedName("alter", conceptName)+".sql")
	if _, err := os.Stat(path); err == nil {
		return nil
	}
	var alters []string
	for _, f := range fields {
		alters = append(alters, fmt.Sprintf("ALTER TABLE %s ADD COLUMN %s %s;", toSnakeCase(conceptName), toSnakeCase(f.Name), sqlType(f.Type)))
	}
	content := strings.Join(alters, "\n") + "\n"
	return os.WriteFile(path, []byte(content), 0o644)
}

func normalizeConcept(c *concept) {
	if c == nil {
		return
	}
	normalizeFields(&c.Fields)
	if len(c.Fields) == 0 {
		c.Fields = append(c.Fields, field{Name: "ID", Type: "string"})
	}
	if !hasField(c.Fields, "ID") {
		c.Fields = append([]field{{Name: "ID", Type: "string"}}, c.Fields...)
	}
	seen := map[string]method{}
	for _, m := range c.Methods {
		name := strings.TrimSpace(m.Name)
		if name == "" {
			continue
		}
		if existing, ok := seen[name]; ok {
			if m.Invariant != "" {
				existing.Invariant = m.Invariant
			}
			if m.Description != "" {
				existing.Description = m.Description
			}
			if m.PreCondition != "" {
				existing.PreCondition = m.PreCondition
			}
			if m.PostCondition != "" {
				existing.PostCondition = m.PostCondition
			}
			seen[name] = existing
			continue
		}
		seen[name] = m
	}
	var out []method
	for _, m := range seen {
		out = append(out, m)
	}
	sort.Slice(out, func(i, j int) bool { return out[i].Name < out[j].Name })
	c.Methods = out
}

func normalizeFields(fields *[]field) {
	if fields == nil {
		return
	}
	unique := map[string]field{}
	for _, f := range *fields {
		name := strings.TrimSpace(f.Name)
		if name == "" {
			continue
		}
		if f.Type == "" {
			f.Type = "string"
		}
		if existing, ok := unique[name]; ok {
			if f.Description != "" {
				existing.Description = f.Description
				unique[name] = existing
			}
		} else {
			unique[name] = field{Name: name, Type: f.Type, Description: f.Description}
		}
	}
	var out []field
	for _, f := range unique {
		out = append(out, f)
	}
	sort.Slice(out, func(i, j int) bool { return out[i].Name < out[j].Name })
	*fields = out
}

func mergeConcept(current concept, add concept) concept {
	if current.Name == "" {
		current.Name = add.Name
	}
	if add.Description != "" {
		current.Description = add.Description
	}
	current.Fields = append(current.Fields, add.Fields...)
	for _, m := range add.Methods {
		found := false
		for i, existing := range current.Methods {
			if existing.Name == m.Name {
				if m.Invariant != "" {
					current.Methods[i].Invariant = m.Invariant
				}
				if m.Description != "" {
					current.Methods[i].Description = m.Description
				}
				if m.PreCondition != "" {
					current.Methods[i].PreCondition = m.PreCondition
				}
				if m.PostCondition != "" {
					current.Methods[i].PostCondition = m.PostCondition
				}
				found = true
				break
			}
		}
		if !found {
			current.Methods = append(current.Methods, m)
		}
	}
	return current
}

func mergeOrchestrator(current orchestrator, add orchestrator) orchestrator {
	if current.Name == "" {
		current.Name = add.Name
	}
	if add.Description != "" {
		current.Description = add.Description
	}
	current.Params = append(current.Params, add.Params...)
	return current
}

func mergeProjection(current projection, add projection) projection {
	if current.Name == "" {
		current.Name = add.Name
	}
	if add.Description != "" {
		current.Description = add.Description
	}
	current.Query = append(current.Query, add.Query...)
	current.Result = append(current.Result, add.Result...)
	return current
}

func mergeRoutes(current []route, add []route) []route {
	seen := map[string]route{}
	for _, r := range current {
		key := r.Method + " " + r.Path + " " + r.Target
		seen[key] = r
	}
	for _, r := range add {
		key := r.Method + " " + r.Path + " " + r.Target
		seen[key] = r
	}
	var out []route
	for _, r := range seen {
		out = append(out, r)
	}
	sort.Slice(out, func(i, j int) bool {
		if out[i].Path == out[j].Path {
			return out[i].Method < out[j].Method
		}
		return out[i].Path < out[j].Path
	})
	return out
}

func diffFields(oldFields, newFields []field) []field {
	lookup := map[string]field{}
	for _, f := range oldFields {
		lookup[f.Name] = f
	}
	var diff []field
	for _, f := range newFields {
		if _, ok := lookup[f.Name]; !ok {
			diff = append(diff, f)
		}
	}
	return diff
}

func uniqueStrings(values []string) []string {
	seen := map[string]struct{}{}
	var out []string
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		if _, ok := seen[v]; ok {
			continue
		}
		seen[v] = struct{}{}
		out = append(out, v)
	}
	sort.Strings(out)
	return out
}

func hasField(fields []field, name string) bool {
	for _, f := range fields {
		if f.Name == name {
			return true
		}
	}
	return false
}

func splitTriple(value string) (string, string, string, error) {
	parts := strings.SplitN(value, ":", 3)
	if len(parts) != 3 {
		return "", "", "", errors.New("expected three colon-separated parts")
	}
	return strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1]), strings.TrimSpace(parts[2]), nil
}

func splitPair(value string) (string, string, error) {
	parts := strings.SplitN(value, ":", 2)
	if len(parts) != 2 {
		return "", "", errors.New("expected two colon-separated parts")
	}
	return strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1]), nil
}

func toSnakeCase(value string) string {
	if value == "" {
		return ""
	}

	var out []rune
	runes := []rune(value)

	for i := 0; i < len(runes); i++ {
		r := runes[i]

		// Handle special characters
		if r == '-' || r == ' ' {
			out = append(out, '_')
			continue
		}

		// Check if this is an uppercase letter
		if r >= 'A' && r <= 'Z' {
			// Add underscore before uppercase if:
			// 1. Not at start (i > 0)
			// 2. Previous char wasn't underscore/dash
			// 3. Not part of all-caps acronym (next char is lowercase OR this is last char after lowercase)
			if i > 0 {
				prev := runes[i-1]
				if prev != '_' && prev != '-' {
					// Check if we're starting a new word (not in middle of acronym)
					// Acronym detection: if previous was uppercase and next is uppercase, we're in acronym
					prevIsUpper := prev >= 'A' && prev <= 'Z'
					nextIsLower := i+1 < len(runes) && runes[i+1] >= 'a' && runes[i+1] <= 'z'

					// Add underscore if:
					// - Previous was lowercase (normal camelCase boundary)
					// - OR we're at end of acronym (prev was upper, next is lower)
					if !prevIsUpper || nextIsLower {
						out = append(out, '_')
					}
				}
			}
		}

		out = append(out, rune(strings.ToLower(string(r))[0]))
	}

	return string(out)
}

func sqlType(goType string) string {
	switch goType {
	case "int", "int32":
		return "INTEGER"
	case "int64":
		return "BIGINT"
	case "bool":
		return "BOOLEAN"
	case "float32":
		return "REAL"
	case "float64":
		return "DOUBLE PRECISION"
	case "time.Time":
		return "TIMESTAMP"
	default:
		return "TEXT"
	}
}

func timestampedName(action, conceptName string) string {
	ts := time.Now().Format("20060102150405")
	return fmt.Sprintf("%s_%s_%s", ts, action, toSnakeCase(conceptName))
}

func writeFileIfMissing(path string, content string, force bool) error {
	if !force {
		if _, err := os.Stat(path); err == nil {
			return nil
		}
	}
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0o644)
}

func writeGeneratedFile(path string, content string, force bool) error {
	if !force {
		if data, err := os.ReadFile(path); err == nil {
			if !strings.Contains(string(data), routesGeneratedTag) {
				return nil
			}
		}
	}
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0o644)
}

func loadState() (state, error) {
	data, err := os.ReadFile(statePath)
	if err != nil {
		if os.IsNotExist(err) {
			return state{}, nil
		}
		return state{}, err
	}
	var s state
	if err := json.Unmarshal(data, &s); err != nil {
		// Try legacy format where Methods was []string
		type legacyConcept struct {
			Name    string   `json:"name"`
			Fields  []field  `json:"fields"`
			Methods []string `json:"methods"`
		}
		type legacyState struct {
			Version       int                      `json:"version"`
			Concepts      map[string]legacyConcept `json:"concepts"`
			Orchestrators map[string]orchestrator  `json:"orchestrators"`
			Projections   map[string]projection    `json:"projections"`
			Routes        []route                  `json:"routes"`
		}
		var ls legacyState
		if err2 := json.Unmarshal(data, &ls); err2 != nil {
			return state{}, err
		}
		s.Version = ls.Version
		s.Concepts = make(map[string]concept)
		for k, v := range ls.Concepts {
			c := concept{
				Name:   v.Name,
				Fields: v.Fields,
			}
			for _, m := range v.Methods {
				c.Methods = append(c.Methods, method{Name: m})
			}
			s.Concepts[k] = c
		}
		s.Orchestrators = ls.Orchestrators
		s.Projections = ls.Projections
		s.Routes = ls.Routes
	}
	if s.Concepts == nil {
		s.Concepts = map[string]concept{}
	}
	if s.Orchestrators == nil {
		s.Orchestrators = map[string]orchestrator{}
	}
	if s.Projections == nil {
		s.Projections = map[string]projection{}
	}
	return s, nil
}

func writeState(s state) error {
	if err := os.MkdirAll(filepath.Dir(statePath), 0o755); err != nil {
		return err
	}
	data, err := json.MarshalIndent(s, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(statePath, data, 0o644)
}

func conceptTemplate(c concept) string {
	type data struct {
		Package   string
		Concept   concept
		NeedsTime bool
	}
	return executeTemplate(`package {{ .Package }}
{{ if .NeedsTime }}
import "time"
{{ end }}
// {{ if .Concept.Description }}{{ .Concept.Description }}{{ else }}{{ .Concept.Name }} holds state for the concept.{{ end }}
type {{ .Concept.Name }} struct {
{{- range .Concept.Fields }}
	{{ if .Description }}// {{ .Description }}
	{{ end }}{{ .Name }} {{ .Type }}
{{- end }}
}

{{ range .Concept.Methods -}}
// {{ .Name }} {{ if .Description }}- {{ .Description }}{{ end }}
func (c *{{ $.Concept.Name }}) {{ .Name }}() {
	// {{ if .PreCondition }}PRE: {{ .PreCondition }}
	// {{ end }}{{ if .Invariant }}INVARIANT: {{ .Invariant }}
	// {{ end }}{{ if .PostCondition }}POST: {{ .PostCondition }}
	// {{ end }}
	{{ if not .Invariant }}// TODO: {{ if .Description }}{{ .Description }}{{ else }}describe state changes and invariants.{{ end }}{{ end }}
}

{{ end -}}
`, data{Package: toSnakeCase(c.Name), Concept: c, NeedsTime: needsTime(c.Fields)})
}

func needsTime(fields []field) bool {
	for _, f := range fields {
		if f.Type == "time.Time" {
			return true
		}
	}
	return false
}

func storageTemplate(moduleName string, c concept) string {
	type data struct {
		Module  string
		Package string
		Concept concept
	}
	return executeTemplate(`package {{ .Package }}

import (
	"context"

	domain "{{ .Module }}/internal/domain/{{ .Package }}"
)

// Store persists {{ .Concept.Name }} state.
type Store interface {
	GetByID(ctx context.Context, id string) (domain.{{ .Concept.Name }}, error)
	Save(ctx context.Context, value domain.{{ .Concept.Name }}) error
	Delete(ctx context.Context, id string) error
	List(ctx context.Context, filter ListFilter) ([]domain.{{ .Concept.Name }}, error)
}

// ListFilter carries filtering parameters for List operations.
type ListFilter struct {
	Limit  int
	Offset int
}
`, data{Module: moduleName, Package: toSnakeCase(c.Name), Concept: c})
}

func orchestratorTemplate(o orchestrator) string {
	type data struct {
		Orchestrator orchestrator
		NeedsTime    bool
	}
	return executeTemplate(`package orchestrators
 
import "context"
{{ if .NeedsTime }}
import "time"
{{ end }}
// {{ .Orchestrator.Name }}Input carries input for the orchestrator.
type {{ .Orchestrator.Name }}Input struct {
{{- range .Orchestrator.Params }}
	{{ if .Description }}// {{ .Description }}
	{{ end }}{{ .Name }} {{ .Type }}
{{- end }}
}

// Execute{{ .Orchestrator.Name }} coordinates concept updates.
// {{ if .Orchestrator.Description }}{{ .Orchestrator.Description }}{{ end }}
func Execute{{ .Orchestrator.Name }}(ctx context.Context, input {{ .Orchestrator.Name }}Input) error {
	// TODO: marshal input into concept operations.
	return nil
}
`, data{Orchestrator: o, NeedsTime: needsTime(o.Params)})
}

func projectionTemplate(p projection) string {
	type data struct {
		Projection projection
		NeedsTime  bool
	}
	return executeTemplate(`package projections
 
import "context"
{{ if .NeedsTime }}
import "time"
{{ end }}
// {{ .Projection.Name }}Query carries query parameters.
type {{ .Projection.Name }}Query struct {
{{- range .Projection.Query }}
	{{ if .Description }}// {{ .Description }}
	{{ end }}{{ .Name }} {{ .Type }}
{{- end }}
}

// {{ .Projection.Name }}Result holds projection output.
type {{ .Projection.Name }}Result struct {
{{- range .Projection.Result }}
	{{ if .Description }}// {{ .Description }}
	{{ end }}{{ .Name }} {{ .Type }}
{{- end }}
}

// Query{{ .Projection.Name }} reads projection state only.
// {{ if .Projection.Description }}{{ .Projection.Description }}{{ end }}
func Query{{ .Projection.Name }}(ctx context.Context, query {{ .Projection.Name }}Query) ({{ .Projection.Name }}Result, error) {
	// TODO: read concept or projection state only.
	return {{ .Projection.Name }}Result{}, nil
}
`, data{Projection: p, NeedsTime: needsTime(p.Query) || needsTime(p.Result)})
}

func routesTemplate(moduleName string, routes []route) string {
	type routeData struct {
		Method      string
		Path        string
		HandlerName string
		Target      string
		IsQuery     bool
	}
	var routeList []routeData
	for _, r := range routes {
		handler := handlerName(r.Method, r.Path, r.Target)
		isQuery := r.Method == "GET"
		routeList = append(routeList, routeData{
			Method:      r.Method,
			Path:        r.Path,
			HandlerName: handler,
			Target:      r.Target,
			IsQuery:     isQuery,
		})
	}

	return executeTemplate(`package web

// `+routesGeneratedTag+`

import (
	"net/http"
{{- if .Routes }}
	"encoding/json"
	"html/template"
	"path/filepath"
	
	"github.com/gorilla/csrf"
{{- end }}
{{ if .Routes }}
	"{{ .Module }}/internal/application/orchestrators"
	"{{ .Module }}/internal/application/projections"
{{ end }}
)

func registerRoutes(mux *http.ServeMux) {
{{- if .Routes }}
{{- range .Routes }}
	mux.HandleFunc("{{ .Path }}", {{ .HandlerName }})
{{- end }}
{{- end }}
}

{{ range .Routes -}}
func {{ .HandlerName }}(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	isHTML := r.Header.Get("Accept") == "text/html"

	if r.Method == "{{ .Method }}" {
		{{- if .IsQuery }}
		`+handlerQueryBody()+`
		{{- else }}
		`+handlerCommandBody()+`
		{{- end }}
		return
	}
	
	`+handlerFallbackFormView()+`

	w.WriteHeader(http.StatusMethodNotAllowed)
}

{{ end -}}
`, struct {
		Module string
		Routes []routeData
	}{Module: moduleName, Routes: routeList})
}

// handlerQueryBody returns the template for GET/Query handlers
func handlerQueryBody() string {
	return `// GET: Projection
		// TODO: parse query params into query struct.
		query := projections.{{ .Target }}Query{} 
		// For simplicity in scaffold, we parse from URL query.
		// e.g. ?id=123 -> query.ID = "123"
		
		result, err := projections.Query{{ .Target }}(ctx, query)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		if isHTML {
			tmplPath := filepath.Join("internal", "adapters", "http", "templates", "{{ .Target | toSnakeCase }}.html")
			layoutPath := filepath.Join("internal", "adapters", "http", "templates", "layout.html")
			
			t, err := template.ParseFiles(layoutPath, tmplPath)
			if err != nil {
				http.Error(w, "Template error: "+err.Error(), http.StatusInternalServerError)
				return
			}
			// Combine result with any other UI data if needed
			if err := t.Execute(w, result); err != nil {
				http.Error(w, "Render error: "+err.Error(), http.StatusInternalServerError)
			}
			return
		}

		if err := json.NewEncoder(w).Encode(result); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}`
}

// handlerCommandBody returns the template for POST/PUT/DELETE/Command handlers
func handlerCommandBody() string {
	return `// POST/PUT/DELETE: Orchestrator
		if isHTML && r.Method == "GET" {
			// Serve the FORM
			tmplPath := filepath.Join("internal", "adapters", "http", "templates", "form_{{ .Target | toSnakeCase }}.html")
			layoutPath := filepath.Join("internal", "adapters", "http", "templates", "layout.html")
			
			t, err := template.ParseFiles(layoutPath, tmplPath)
			if err != nil {
				http.Error(w, "Template error: "+err.Error(), http.StatusInternalServerError)
				return
			}
			
			data := struct {
				CSRFToken string
			}{
				CSRFToken: csrf.Token(r),
			}
			
			if err := t.Execute(w, data); err != nil {
				http.Error(w, "Render error: "+err.Error(), http.StatusInternalServerError)
			}
			return
		}

		// Handle Form Submission or JSON body
		input := orchestrators.{{ .Target }}Input{}
		
		if r.Header.Get("Content-Type") == "application/x-www-form-urlencoded" {
			if err := r.ParseForm(); err != nil {
				http.Error(w, "Form error: "+err.Error(), http.StatusBadRequest)
				return
			}
			// Map Form values to Input
			// scaffold TODO: use reflection or generate explicit mapping
			// For basic scaffold, we leave it to the user or assume matching names.
		} else {
			// JSON
			// if err := json.NewDecoder(r.Body).Decode(&input); err != nil { ... }
		}

		if err := orchestrators.Execute{{ .Target }}(ctx, input); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		
		if isHTML {
			http.Redirect(w, r, "/", http.StatusSeeOther)
		} else {
			w.WriteHeader(http.StatusNoContent)
		}`
}

// handlerFallbackFormView returns the template for fallback form view on GET
func handlerFallbackFormView() string {
	return `// Fallback: serve form for non-GET routes when accessed via GET+HTML
	if isHTML && r.Method == "GET" && "{{ .Method }}" != "GET" {
		tmplPath := filepath.Join("internal", "adapters", "http", "templates", "form_{{ .Target | toSnakeCase }}.html")
		layoutPath := filepath.Join("internal", "adapters", "http", "templates", "layout.html")
		
		t, err := template.ParseFiles(layoutPath, tmplPath)
		if err != nil {
			http.Error(w, "Template error: "+err.Error(), http.StatusInternalServerError)
			return
		}
		
		data := struct {
			CSRFToken string
		}{
			CSRFToken: csrf.Token(r),
		}
		
		if err := t.Execute(w, data); err != nil {
			http.Error(w, "Render error: "+err.Error(), http.StatusInternalServerError)
		}
		return
	}`
}

func handlerName(method, path, target string) string {
	segments := strings.FieldsFunc(path, func(r rune) bool {
		return r == '/' || r == '-' || r == '_' || r == '{' || r == '}'
	})
	var parts []string
	for _, s := range segments {
		if s == "" {
			continue
		}
		parts = append(parts, titleCase(s))
	}
	return fmt.Sprintf("handle%s%s%s", titleCase(strings.ToLower(method)), strings.Join(parts, ""), target)
}

func titleCase(s string) string {
	if len(s) == 0 {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func executeTemplate(tmpl string, data any) string {
	funcMap := template.FuncMap{
		"toSnakeCase": toSnakeCase,
	}
	parsed := template.Must(template.New("tmpl").Funcs(funcMap).Parse(tmpl))
	var b strings.Builder
	if err := parsed.Execute(&b, data); err != nil {
		panic(err)
	}
	return b.String()
}

func resolveModuleName(flagValue string) (string, error) {
	existing, err := readModuleName()
	if err != nil {
		return "", err
	}
	if flagValue != "" {
		if existing != "" && existing != flagValue {
			return "", fmt.Errorf("module flag %q does not match go.mod module %q", flagValue, existing)
		}
		return flagValue, nil
	}
	if existing != "" {
		return existing, nil
	}
	return "workshop", nil
}

func readModuleName() (string, error) {
	data, err := os.ReadFile("go.mod")
	if err != nil {
		if os.IsNotExist(err) {
			return "", nil
		}
		return "", err
	}
	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module ")), nil
		}
	}
	return "", nil
}

func goModTemplate(moduleName string) string {
	return fmt.Sprintf(`module %s

go 1.21

require (
	github.com/gorilla/csrf v1.7.2
	modernc.org/sqlite v1.28.0
)
`, moduleName)
}

func serverMainTemplate(moduleName string) string {
	return executeTemplate(`package main

import (
	"log"
	"net/http"

	web "{{ .Module }}/internal/adapters/http"
)

func main() {
	mux := web.NewMux("./static")

	addr := ":8080"
	server := &http.Server{Addr: addr, Handler: mux}

	log.Printf("listening on %s", addr)
	if err := server.ListenAndServe(); err != nil {
		log.Fatal(err)
	}
}
`, struct{ Module string }{Module: moduleName})
}

func webTemplate(moduleName string) string {
	return executeTemplate(`package web

import (
	"net/http"
	
	"{{ .Module }}/internal/adapters/http/middleware"
)

// NewMux wires HTTP handlers for the app.
func NewMux(staticDir string) http.Handler {
	mux := http.NewServeMux()
	mux.Handle("/", http.FileServer(http.Dir(staticDir)))
	registerRoutes(mux)
	
	// Create CSRF protection
	// SECURITY: In production, load this key from an environment variable or secrets manager.
	// The key must be 32 bytes for AES-256 encryption. Never commit production keys to version control.
	csrfKey := []byte("01234567890123456789012345678901") // 32 bytes (dev only)
	
	// Apply middleware: CSRF -> SecurityHeaders -> Mux
	return middleware.Chain(mux, middleware.SecurityHeaders, middleware.CSRF(csrfKey))
}
`, struct{ Module string }{Module: moduleName})
}
func dbTemplate(moduleName string) string {
	return executeTemplate(`package storage

import (
	"database/sql"
	"log"

	_ "modernc.org/sqlite"
)

func Init(dbPath string) *sql.DB {
	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		log.Fatal(err)
	}
	if err := db.Ping(); err != nil {
		log.Fatal(err)
	}
	return db
}
`, nil)
}

func middlewareTemplate(moduleName string) string {
	return executeTemplate(`package middleware

import (
	"net/http"

	"github.com/gorilla/csrf"
)

// SecurityHeaders adds OWASP recommended headers.
func SecurityHeaders(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Content Security Policy (Basic)
		// Allow scripts/styles from 'self' and inline (for now, scaffold simplicity)
		// In production, use nonces/hashes.
		w.Header().Set("Content-Security-Policy", "default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'")
		w.Header().Set("X-Frame-Options", "DENY")
		w.Header().Set("X-Content-Type-Options", "nosniff")
		w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")
		next.ServeHTTP(w, r)
	})
}

// CSRFMiddleware returns a handler that protects against CSRF attacks.
// It assumes an encryption key is passed (32 bytes).
func CSRF(authKey []byte) func(http.Handler) http.Handler {
	// Secure: true requires HTTPS. For local dev (scaffold), we might want Insecure if strictly http.
	// But let's default to Secure=false for localhost ease, or user can toggle.
	// We'll use defaults which are Secure=true in Prod.
	return csrf.Protect(authKey, csrf.Secure(false), csrf.Path("/")) 
}

// Chain applies middlewares in order (outer to inner).
func Chain(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
	for _, m := range middlewares {
		h = m(h)
	}
	return h
}
`, nil)
}

func sqliteStoreTemplate(moduleName string, c concept) string {
	type data struct {
		Module  string
		Package string
		Concept concept
	}
	return executeTemplate(`package {{ .Package }}

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	domain "{{ .Module }}/internal/domain/{{ .Package }}"
)

// SQLiteStore implements domain.{{ .Concept.Name }}Store using SQLite.
type SQLiteStore struct {
	db *sql.DB
}

// NewSQLiteStore creates a new {{ .Concept.Name }}Store.
func NewSQLiteStore(db *sql.DB) *SQLiteStore {
	return &SQLiteStore{db: db}
}

// GetByID retrieves a {{ .Concept.Name }} by its ID.
func (s *SQLiteStore) GetByID(ctx context.Context, id string) (domain.{{ .Concept.Name }}, error) {
	query := "SELECT {{ range $i, $f := .Concept.Fields }}{{ if $i }}, {{ end }}{{ $f.Name | toSnakeCase }}{{ end }} FROM {{ .Concept.Name | toSnakeCase }} WHERE id = ?"
	
	row := s.db.QueryRowContext(ctx, query, id)
	
	var entity domain.{{ .Concept.Name }}
	err := row.Scan(
{{- range .Concept.Fields }}
		&entity.{{ .Name }},
{{- end }}
	)
	if err == sql.ErrNoRows {
		return domain.{{ .Concept.Name }}{}, fmt.Errorf("{{ .Concept.Name | toSnakeCase }} not found: %w", err)
	}
	return entity, err
}

// Save persists a {{ .Concept.Name }} to the database.
func (s *SQLiteStore) Save(ctx context.Context, entity domain.{{ .Concept.Name }}) error {
	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()

	// Upsert implementation
	fields := []string{ {{ range .Concept.Fields }}"{{ .Name | toSnakeCase }}",{{ end }} }
	placeholders := []string{ {{ range .Concept.Fields }}"?",{{ end }} }
	updates := []string{ {{ range .Concept.Fields }}"{{ .Name | toSnakeCase }}=excluded.{{ .Name | toSnakeCase }}",{{ end }} }

	query := fmt.Sprintf(
		"INSERT INTO {{ .Concept.Name | toSnakeCase }} (%s) VALUES (%s) ON CONFLICT(id) DO UPDATE SET %s",
		strings.Join(fields, ", "),
		strings.Join(placeholders, ", "),
		strings.Join(updates, ", "),
	)

	_, err = tx.ExecContext(ctx, query,
{{- range .Concept.Fields }}
		entity.{{ .Name }},
{{- end }}
	)
	if err != nil {
		return err
	}

	return tx.Commit()
}

// Delete removes a {{ .Concept.Name }} from the database.
func (s *SQLiteStore) Delete(ctx context.Context, id string) error {
	_, err := s.db.ExecContext(ctx, "DELETE FROM {{ .Concept.Name | toSnakeCase }} WHERE id = ?", id)
	return err
}

// List retrieves a list of {{ .Concept.Name }}s based on the filter.
func (s *SQLiteStore) List(ctx context.Context, filter ListFilter) ([]domain.{{ .Concept.Name }}, error) {
	query := "SELECT {{ range $i, $f := .Concept.Fields }}{{ if $i }}, {{ end }}{{ $f.Name | toSnakeCase }}{{ end }} FROM {{ .Concept.Name | toSnakeCase }} LIMIT ? OFFSET ?"
	
	rows, err := s.db.QueryContext(ctx, query, filter.Limit, filter.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []domain.{{ .Concept.Name }}
	for rows.Next() {
		var entity domain.{{ .Concept.Name }}
		if err := rows.Scan(
{{- range .Concept.Fields }}
			&entity.{{ .Name }},
{{- end }}
		); err != nil {
			return nil, err
		}
		results = append(results, entity)
	}
	return results, nil
}
`, data{Module: moduleName, Package: toSnakeCase(c.Name), Concept: c})
}

func layoutHTMLTemplate() string {
	return executeTemplate(`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workshop App</title>
    <link rel="stylesheet" href="/styles.css">
    <style>
        body { font-family: system-ui, sans-serif; max-width: 800px; margin: 0 auto; padding: 2rem; background: #f4f4f4; }
        header { background: #333; color: #fff; padding: 1rem; border-radius: 8px; margin-bottom: 2rem; }
        nav a { color: #fff; text-decoration: none; margin-right: 1rem; font-weight: bold; }
        .card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { margin-top: 0; }
        dl { display: grid; grid-template-columns: auto 1fr; gap: 0.5rem 2rem; }
        dt { font-weight: bold; color: #666; }
        .form-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: bold; }
        input[type="text"], input[type="number"] { width: 100%; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }
        button { background: #007bff; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 4px; cursor: pointer; font-size: 1rem; }
        button:hover { background: #0056b3; }
        footer { margin-top: 3rem; text-align: center; color: #888; border-top: 1px solid #ddd; padding-top: 1rem; }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="/">Home</a>
        </nav>
    </header>
    <main>
        {{ printf "{{ template \"content\" . }}" }}
    </main>
    <footer>
        <p>&copy; 2026 Workshop</p>
    </footer>
</body>
</html>`, nil)
}

func viewHTMLTemplate(p projection) string {
	return executeTemplate(`{{ printf "{{ define \"content\" }}" }}
<div class="card">
    <h1>{{ .Projection.Name }}</h1>
    <dl>
    {{- range .Projection.Result }}
        <dt>{{ .Name }}</dt>
        <dd>{{ printf "{{ .%s }}" .Name }}</dd>
    {{- end }}
    </dl>
    <p><a href="/">Back</a></p>
</div>
{{ printf "{{ end }}" }}`, struct{ Projection projection }{Projection: p})
}

func formHTMLTemplate(o orchestrator) string {
	return executeTemplate(`{{ printf "{{ define \"content\" }}" }}
<div class="card">
    <h1>{{ .Orchestrator.Name }}</h1>
    <form method="POST">
        <input type="hidden" name="gorilla.csrf.Token" value="{{ printf "{{ .CSRFToken }}" }}">
        
        {{- range .Orchestrator.Params }}
        <div class="form-group">
            <label for="id_{{ .Name }}">{{ .Name }}</label>
            {{ if eq .Type "int" -}}
            <input type="number" id="id_{{ .Name }}" name="{{ .Name }}" required>
            {{- else if eq .Type "bool" -}}
            <input type="checkbox" id="id_{{ .Name }}" name="{{ .Name }}" value="true">
            {{- else -}}
            <input type="text" id="id_{{ .Name }}" name="{{ .Name }}" required>
            {{- end }}
        </div>
        {{- end }}
        
        <button type="submit">Submit</button>
    </form>
    <p><a href="/">Cancel</a></p>
</div>
{{ printf "{{ end }}" }}`, struct{ Orchestrator orchestrator }{Orchestrator: o})
}
