package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
)

const (
	statePath          = ".scaffold/state.json"
	routesGeneratedTag = "Code generated by scaffold; DO NOT EDIT."
)

type field struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

type concept struct {
	Name    string  `json:"name"`
	Fields  []field `json:"fields"`
	Methods []string
}

type orchestrator struct {
	Name   string  `json:"name"`
	Params []field `json:"params"`
}

type projection struct {
	Name   string  `json:"name"`
	Query  []field `json:"query"`
	Result []field `json:"result"`
}

type route struct {
	Method string `json:"method"`
	Path   string `json:"path"`
	Target string `json:"target"`
}

type state struct {
	Version       int                     `json:"version"`
	Concepts      map[string]concept      `json:"concepts"`
	Orchestrators map[string]orchestrator `json:"orchestrators"`
	Projections   map[string]projection   `json:"projections"`
	Routes        []route                 `json:"routes"`
}

type multiFlag []string

func (m *multiFlag) String() string { return strings.Join(*m, ",") }
func (m *multiFlag) Set(value string) error {
	*m = append(*m, value)
	return nil
}

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(2)
	}

	switch os.Args[1] {
	case "init":
		if err := runInit(os.Args[2:]); err != nil {
			fmt.Fprintln(os.Stderr, "scaffold:", err)
			os.Exit(1)
		}
	default:
		printUsage()
		os.Exit(2)
	}
}

func printUsage() {
	fmt.Println("usage: scaffold init [flags]")
	fmt.Println("flags:")
	fmt.Println("  --concept Name")
	fmt.Println("  --field Concept:Field:Type")
	fmt.Println("  --method Concept:Method")
	fmt.Println("  --orchestrator Name")
	fmt.Println("  --param Orchestrator:Param:Type")
	fmt.Println("  --projection Name")
	fmt.Println("  --query Projection:Field:Type")
	fmt.Println("  --result Projection:Field:Type")
	fmt.Println("  --route Method:Path:Target")
	fmt.Println("  --force (overwrite existing files)")
}

func runInit(args []string) error {
	var (
		conceptFlags      multiFlag
		fieldFlags        multiFlag
		methodFlags       multiFlag
		orchestratorFlags multiFlag
		paramFlags        multiFlag
		projectionFlags   multiFlag
		queryFlags        multiFlag
		resultFlags       multiFlag
		routeFlags        multiFlag
		force             bool
	)

	fs := flag.NewFlagSet("init", flag.ContinueOnError)
	fs.SetOutput(os.Stderr)
	fs.Var(&conceptFlags, "concept", "concept name")
	fs.Var(&fieldFlags, "field", "concept field: Concept:Field:Type")
	fs.Var(&methodFlags, "method", "concept method: Concept:Method")
	fs.Var(&orchestratorFlags, "orchestrator", "orchestrator name")
	fs.Var(&paramFlags, "param", "orchestrator param: Orchestrator:Param:Type")
	fs.Var(&projectionFlags, "projection", "projection name")
	fs.Var(&queryFlags, "query", "projection query field: Projection:Field:Type")
	fs.Var(&resultFlags, "result", "projection result field: Projection:Field:Type")
	fs.Var(&routeFlags, "route", "route: Method:Path:Target")
	fs.BoolVar(&force, "force", false, "overwrite existing files")
	if err := fs.Parse(args); err != nil {
		return err
	}

	current, err := loadState()
	if err != nil {
		return err
	}

	if err := ensureBaseLayout(force); err != nil {
		return err
	}

	desired := buildDesiredState(conceptFlags, fieldFlags, methodFlags, orchestratorFlags, paramFlags, projectionFlags, queryFlags, resultFlags, routeFlags)
	updated, err := applyState(current, desired, force)
	if err != nil {
		return err
	}

	if err := writeState(updated); err != nil {
		return err
	}

	return nil
}

func ensureBaseLayout(force bool) error {
	dirs := []string{
		"internal/domain",
		"internal/application",
		"internal/application/orchestrators",
		"internal/application/projections",
		"internal/adapters/http",
		"internal/adapters/storage",
		"internal/adapters/storage/migrations",
		"cmd/server",
	}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return err
		}
	}

	if err := writeFileIfMissing("internal/domain/README.md", "# Domain (Concepts)\n\nPlace concept state and methods here.\n", force); err != nil {
		return err
	}
	if err := writeFileIfMissing("internal/application/README.md", "# Application (Orchestrators + Projections)\n\nPlace orchestrators and projections here.\n", force); err != nil {
		return err
	}
	if err := writeGeneratedFile("internal/adapters/http/routes.go", routesTemplate(nil), force); err != nil {
		return err
	}

	return nil
}

func buildDesiredState(
	concepts, fields, methods, orchestrators, params, projections, queries, results, routes multiFlag,
) state {
	desired := state{
		Version:       1,
		Concepts:      map[string]concept{},
		Orchestrators: map[string]orchestrator{},
		Projections:   map[string]projection{},
		Routes:        []route{},
	}

	for _, c := range concepts {
		name := strings.TrimSpace(c)
		if name == "" {
			continue
		}
		desired.Concepts[name] = concept{Name: name}
	}
	for _, f := range fields {
		conceptName, fieldName, fieldType, err := splitTriple(f)
		if err != nil {
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		c.Fields = append(c.Fields, field{Name: fieldName, Type: fieldType})
		desired.Concepts[conceptName] = c
	}
	for _, m := range methods {
		conceptName, methodName, err := splitPair(m)
		if err != nil {
			continue
		}
		c := desired.Concepts[conceptName]
		c.Name = conceptName
		c.Methods = append(c.Methods, methodName)
		desired.Concepts[conceptName] = c
	}
	for _, o := range orchestrators {
		name := strings.TrimSpace(o)
		if name == "" {
			continue
		}
		desired.Orchestrators[name] = orchestrator{Name: name}
	}
	for _, p := range params {
		orchName, fieldName, fieldType, err := splitTriple(p)
		if err != nil {
			continue
		}
		o := desired.Orchestrators[orchName]
		o.Name = orchName
		o.Params = append(o.Params, field{Name: fieldName, Type: fieldType})
		desired.Orchestrators[orchName] = o
	}
	for _, p := range projections {
		name := strings.TrimSpace(p)
		if name == "" {
			continue
		}
		desired.Projections[name] = projection{Name: name}
	}
	for _, q := range queries {
		projName, fieldName, fieldType, err := splitTriple(q)
		if err != nil {
			continue
		}
		p := desired.Projections[projName]
		p.Name = projName
		p.Query = append(p.Query, field{Name: fieldName, Type: fieldType})
		desired.Projections[projName] = p
	}
	for _, r := range results {
		projName, fieldName, fieldType, err := splitTriple(r)
		if err != nil {
			continue
		}
		p := desired.Projections[projName]
		p.Name = projName
		p.Result = append(p.Result, field{Name: fieldName, Type: fieldType})
		desired.Projections[projName] = p
	}
	for _, r := range routes {
		method, path, target, err := splitTriple(r)
		if err != nil {
			continue
		}
		desired.Routes = append(desired.Routes, route{Method: strings.ToUpper(method), Path: path, Target: target})
	}

	return desired
}

func applyState(current state, desired state, force bool) (state, error) {
	if current.Version == 0 {
		current = state{
			Version:       1,
			Concepts:      map[string]concept{},
			Orchestrators: map[string]orchestrator{},
			Projections:   map[string]projection{},
			Routes:        []route{},
		}
	}

	for name, c := range desired.Concepts {
		currentConcept := current.Concepts[name]
		merged := mergeConcept(currentConcept, c)
		current.Concepts[name] = merged

		if err := scaffoldConcept(merged, currentConcept, force); err != nil {
			return current, err
		}
	}

	for name, o := range desired.Orchestrators {
		currentOrch := current.Orchestrators[name]
		merged := mergeOrchestrator(currentOrch, o)
		current.Orchestrators[name] = merged

		if err := scaffoldOrchestrator(merged, force); err != nil {
			return current, err
		}
	}

	for name, p := range desired.Projections {
		currentProj := current.Projections[name]
		merged := mergeProjection(currentProj, p)
		current.Projections[name] = merged

		if err := scaffoldProjection(merged, force); err != nil {
			return current, err
		}
	}

	if len(desired.Routes) > 0 {
		current.Routes = mergeRoutes(current.Routes, desired.Routes)
		if err := scaffoldRoutes(current.Routes, force); err != nil {
			return current, err
		}
	}

	return current, nil
}

func scaffoldConcept(c concept, previous concept, force bool) error {
	normalizeConcept(&c)

	conceptDir := filepath.Join("internal/domain", toSnakeCase(c.Name))
	if err := os.MkdirAll(conceptDir, 0o755); err != nil {
		return err
	}

	modelPath := filepath.Join(conceptDir, "model.go")
	if err := writeFileIfMissing(modelPath, conceptTemplate(c), force); err != nil {
		return err
	}

	storeDir := filepath.Join("internal/adapters/storage", toSnakeCase(c.Name))
	if err := os.MkdirAll(storeDir, 0o755); err != nil {
		return err
	}
	storePath := filepath.Join(storeDir, "store.go")
	if err := writeFileIfMissing(storePath, storageTemplate(c), force); err != nil {
		return err
	}

	if err := writeMigration(c, previous); err != nil {
		return err
	}

	return nil
}

func scaffoldOrchestrator(o orchestrator, force bool) error {
	normalizeFields(&o.Params)
	path := filepath.Join("internal/application/orchestrators", toSnakeCase(o.Name)+".go")
	return writeFileIfMissing(path, orchestratorTemplate(o), force)
}

func scaffoldProjection(p projection, force bool) error {
	normalizeFields(&p.Query)
	normalizeFields(&p.Result)
	path := filepath.Join("internal/application/projections", toSnakeCase(p.Name)+".go")
	return writeFileIfMissing(path, projectionTemplate(p), force)
}

func scaffoldRoutes(routes []route, force bool) error {
	sort.Slice(routes, func(i, j int) bool {
		if routes[i].Path == routes[j].Path {
			return routes[i].Method < routes[j].Method
		}
		return routes[i].Path < routes[j].Path
	})
	content := routesTemplate(routes)
	return writeGeneratedFile("internal/adapters/http/routes.go", content, force)
}

func writeMigration(current concept, previous concept) error {
	prevIsNew := len(previous.Fields) == 0

	normalizeConcept(&current)
	normalizeConcept(&previous)

	if prevIsNew {
		return writeCreateMigration(current)
	}

	newFields := diffFields(previous.Fields, current.Fields)
	if len(newFields) == 0 {
		return nil
	}

	return writeAlterMigration(current.Name, newFields)
}

func writeCreateMigration(c concept) error {
	path := filepath.Join("internal/adapters/storage/migrations", timestampedName("create", c.Name)+".sql")
	if _, err := os.Stat(path); err == nil {
		return nil
	}

	var columns []string
	for _, f := range c.Fields {
		columns = append(columns, fmt.Sprintf("  %s %s", toSnakeCase(f.Name), sqlType(f.Type)))
	}
	content := fmt.Sprintf("CREATE TABLE %s (\n%s\n);\n", toSnakeCase(c.Name), strings.Join(columns, ",\n"))
	return os.WriteFile(path, []byte(content), 0o644)
}

func writeAlterMigration(conceptName string, fields []field) error {
	path := filepath.Join("internal/adapters/storage/migrations", timestampedName("alter", conceptName)+".sql")
	if _, err := os.Stat(path); err == nil {
		return nil
	}
	var alters []string
	for _, f := range fields {
		alters = append(alters, fmt.Sprintf("ALTER TABLE %s ADD COLUMN %s %s;", toSnakeCase(conceptName), toSnakeCase(f.Name), sqlType(f.Type)))
	}
	content := strings.Join(alters, "\n") + "\n"
	return os.WriteFile(path, []byte(content), 0o644)
}

func normalizeConcept(c *concept) {
	if c == nil {
		return
	}
	normalizeFields(&c.Fields)
	if len(c.Fields) == 0 {
		c.Fields = append(c.Fields, field{Name: "ID", Type: "string"})
	}
	if !hasField(c.Fields, "ID") {
		c.Fields = append([]field{{Name: "ID", Type: "string"}}, c.Fields...)
	}
	c.Methods = uniqueStrings(c.Methods)
}

func normalizeFields(fields *[]field) {
	if fields == nil {
		return
	}
	unique := map[string]field{}
	for _, f := range *fields {
		name := strings.TrimSpace(f.Name)
		if name == "" {
			continue
		}
		if f.Type == "" {
			f.Type = "string"
		}
		unique[name] = field{Name: name, Type: f.Type}
	}
	var out []field
	for _, f := range unique {
		out = append(out, f)
	}
	sort.Slice(out, func(i, j int) bool { return out[i].Name < out[j].Name })
	*fields = out
}

func mergeConcept(current concept, add concept) concept {
	if current.Name == "" {
		current.Name = add.Name
	}
	current.Fields = append(current.Fields, add.Fields...)
	current.Methods = append(current.Methods, add.Methods...)
	return current
}

func mergeOrchestrator(current orchestrator, add orchestrator) orchestrator {
	if current.Name == "" {
		current.Name = add.Name
	}
	current.Params = append(current.Params, add.Params...)
	return current
}

func mergeProjection(current projection, add projection) projection {
	if current.Name == "" {
		current.Name = add.Name
	}
	current.Query = append(current.Query, add.Query...)
	current.Result = append(current.Result, add.Result...)
	return current
}

func mergeRoutes(current []route, add []route) []route {
	seen := map[string]route{}
	for _, r := range current {
		key := r.Method + " " + r.Path + " " + r.Target
		seen[key] = r
	}
	for _, r := range add {
		key := r.Method + " " + r.Path + " " + r.Target
		seen[key] = r
	}
	var out []route
	for _, r := range seen {
		out = append(out, r)
	}
	sort.Slice(out, func(i, j int) bool {
		if out[i].Path == out[j].Path {
			return out[i].Method < out[j].Method
		}
		return out[i].Path < out[j].Path
	})
	return out
}

func diffFields(oldFields, newFields []field) []field {
	lookup := map[string]field{}
	for _, f := range oldFields {
		lookup[f.Name] = f
	}
	var diff []field
	for _, f := range newFields {
		if _, ok := lookup[f.Name]; !ok {
			diff = append(diff, f)
		}
	}
	return diff
}

func uniqueStrings(values []string) []string {
	seen := map[string]struct{}{}
	var out []string
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		if _, ok := seen[v]; ok {
			continue
		}
		seen[v] = struct{}{}
		out = append(out, v)
	}
	sort.Strings(out)
	return out
}

func hasField(fields []field, name string) bool {
	for _, f := range fields {
		if f.Name == name {
			return true
		}
	}
	return false
}

func splitTriple(value string) (string, string, string, error) {
	parts := strings.Split(value, ":")
	if len(parts) != 3 {
		return "", "", "", errors.New("expected three colon-separated parts")
	}
	return strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1]), strings.TrimSpace(parts[2]), nil
}

func splitPair(value string) (string, string, error) {
	parts := strings.Split(value, ":")
	if len(parts) != 2 {
		return "", "", errors.New("expected two colon-separated parts")
	}
	return strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1]), nil
}

func toSnakeCase(value string) string {
	var out []rune
	for i, r := range value {
		if i > 0 && r >= 'A' && r <= 'Z' {
			prev := rune(value[i-1])
			if prev != '_' && prev != '-' {
				out = append(out, '_')
			}
		}
		if r == '-' || r == ' ' {
			out = append(out, '_')
			continue
		}
		out = append(out, rune(strings.ToLower(string(r))[0]))
	}
	return string(out)
}

func sqlType(goType string) string {
	switch goType {
	case "int", "int32":
		return "INTEGER"
	case "int64":
		return "BIGINT"
	case "bool":
		return "BOOLEAN"
	case "float32":
		return "REAL"
	case "float64":
		return "DOUBLE PRECISION"
	case "time.Time":
		return "TIMESTAMP"
	default:
		return "TEXT"
	}
}

func timestampedName(action, conceptName string) string {
	ts := time.Now().Format("20060102150405")
	return fmt.Sprintf("%s_%s_%s", ts, action, toSnakeCase(conceptName))
}

func writeFileIfMissing(path string, content string, force bool) error {
	if !force {
		if _, err := os.Stat(path); err == nil {
			return nil
		}
	}
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0o644)
}

func writeGeneratedFile(path string, content string, force bool) error {
	if !force {
		if data, err := os.ReadFile(path); err == nil {
			if !strings.Contains(string(data), routesGeneratedTag) {
				return nil
			}
		}
	}
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0o644)
}

func loadState() (state, error) {
	data, err := os.ReadFile(statePath)
	if err != nil {
		if os.IsNotExist(err) {
			return state{}, nil
		}
		return state{}, err
	}
	var s state
	if err := json.Unmarshal(data, &s); err != nil {
		return state{}, err
	}
	if s.Concepts == nil {
		s.Concepts = map[string]concept{}
	}
	if s.Orchestrators == nil {
		s.Orchestrators = map[string]orchestrator{}
	}
	if s.Projections == nil {
		s.Projections = map[string]projection{}
	}
	return s, nil
}

func writeState(s state) error {
	if err := os.MkdirAll(filepath.Dir(statePath), 0o755); err != nil {
		return err
	}
	data, err := json.MarshalIndent(s, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(statePath, data, 0o644)
}

func conceptTemplate(c concept) string {
	type data struct {
		Package string
		Concept concept
	}
	return executeTemplate(`package {{ .Package }}

// {{ .Concept.Name }} holds state for the concept.
type {{ .Concept.Name }} struct {
{{- range .Concept.Fields }}
	{{ .Name }} {{ .Type }}
{{- end }}
}

{{ range .Concept.Methods -}}
func (c *{{ $.Concept.Name }}) {{ . }}() {
	// TODO: describe state changes and invariants.
}

{{ end -}}
`, data{Package: toSnakeCase(c.Name), Concept: c})
}

func storageTemplate(c concept) string {
	type data struct {
		Package string
		Concept concept
	}
	return executeTemplate(`package {{ .Package }}

import "context"

// Store persists {{ .Concept.Name }} state.
type Store interface {
	GetByID(ctx context.Context, id string) ({{ .Concept.Name }}, error)
	Save(ctx context.Context, value {{ .Concept.Name }}) error
}
`, data{Package: toSnakeCase(c.Name), Concept: c})
}

func orchestratorTemplate(o orchestrator) string {
	type data struct {
		Orchestrator orchestrator
	}
	return executeTemplate(`package orchestrators

import "context"

// {{ .Orchestrator.Name }}Input carries input for the orchestrator.
type {{ .Orchestrator.Name }}Input struct {
{{- range .Orchestrator.Params }}
	{{ .Name }} {{ .Type }}
{{- end }}
}

// Execute{{ .Orchestrator.Name }} coordinates concept updates.
func Execute{{ .Orchestrator.Name }}(ctx context.Context, input {{ .Orchestrator.Name }}Input) error {
	// TODO: marshal input into concept operations.
	return nil
}
`, data{Orchestrator: o})
}

func projectionTemplate(p projection) string {
	type data struct {
		Projection projection
	}
	return executeTemplate(`package projections

import "context"

// {{ .Projection.Name }}Query carries query parameters.
type {{ .Projection.Name }}Query struct {
{{- range .Projection.Query }}
	{{ .Name }} {{ .Type }}
{{- end }}
}

// {{ .Projection.Name }}Result holds projection output.
type {{ .Projection.Name }}Result struct {
{{- range .Projection.Result }}
	{{ .Name }} {{ .Type }}
{{- end }}
}

// Query{{ .Projection.Name }} reads projection state only.
func Query{{ .Projection.Name }}(ctx context.Context, query {{ .Projection.Name }}Query) ({{ .Projection.Name }}Result, error) {
	// TODO: read concept or projection state only.
	return {{ .Projection.Name }}Result{}, nil
}
`, data{Projection: p})
}

func routesTemplate(routes []route) string {
	type routeData struct {
		Method      string
		Path        string
		HandlerName string
		Target      string
		IsQuery     bool
	}
	var data []routeData
	for _, r := range routes {
		handler := handlerName(r.Method, r.Path, r.Target)
		isQuery := r.Method == "GET"
		data = append(data, routeData{
			Method:      r.Method,
			Path:        r.Path,
			HandlerName: handler,
			Target:      r.Target,
			IsQuery:     isQuery,
		})
	}

	return executeTemplate(`package web

// `+routesGeneratedTag+`

import "net/http"

{{ if . }}
import (
	"encoding/json"

	"workshop/internal/application/orchestrators"
	"workshop/internal/application/projections"
)
{{ end }}

func registerRoutes(mux *http.ServeMux) {
{{- if . }}
{{- range . }}
	mux.HandleFunc("{{ .Path }}", {{ .HandlerName }})
{{- end }}
{{- end }}
}

{{ range . -}}
func {{ .HandlerName }}(w http.ResponseWriter, r *http.Request) {
	if r.Method != "{{ .Method }}" {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
	ctx := r.Context()

	{{- if .IsQuery }}
	// TODO: parse query params into query struct.
	query := projections.{{ .Target }}Query{}
	result, err := projections.Query{{ .Target }}(ctx, query)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := json.NewEncoder(w).Encode(result); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	{{- else }}
	// TODO: parse request body into input struct.
	input := orchestrators.{{ .Target }}Input{}
	if err := orchestrators.Execute{{ .Target }}(ctx, input); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
	{{- end }}
}

{{ end -}}
`, data)
}

func handlerName(method, path, target string) string {
	segments := strings.FieldsFunc(path, func(r rune) bool {
		return r == '/' || r == '-' || r == '_'
	})
	var parts []string
	for _, s := range segments {
		if s == "" {
			continue
		}
		parts = append(parts, strings.Title(s))
	}
	return fmt.Sprintf("handle%s%s%s", strings.Title(strings.ToLower(method)), strings.Join(parts, ""), target)
}

func executeTemplate(tmpl string, data any) string {
	parsed := template.Must(template.New("tmpl").Parse(tmpl))
	var b strings.Builder
	if err := parsed.Execute(&b, data); err != nil {
		panic(err)
	}
	return b.String()
}
