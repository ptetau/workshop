name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "deploy" to confirm production deployment'
        required: true
        type: string

permissions:
  contents: write

jobs:
  gate:
    name: Pre-Deploy Checks
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm == 'deploy'

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff # v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Go mod tidy check
        run: |
          go mod tidy
          git diff --exit-code go.mod go.sum

      - name: Build
        run: go build ./...

      - name: Vet
        run: go vet ./...

      - name: Format check
        run: |
          unformatted=$(gofmt -l .)
          if [ -n "$unformatted" ]; then
            echo "The following files are not formatted:"
            echo "$unformatted"
            exit 1
          fi

      - name: Unit tests (with race detector)
        run: go test -race -count=1 -short ./...
        env:
          CGO_ENABLED: "1"

      - name: Install Playwright browsers
        run: go run github.com/playwright-community/playwright-go/cmd/playwright install --with-deps chromium

      - name: Browser tests
        run: go test -count=1 -v ./tests/browser/...
        env:
          CGO_ENABLED: "1"

      - name: Lint guidelines
        run: go run ./tools/lintguidelines --root . --strict

  deploy:
    name: Build & Deploy to VPS
    runs-on: ubuntu-latest
    needs: gate

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Configure git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff # v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Compute version
        id: version
        run: |
          BASE=$(cat VERSION | tr -d '\n\r')
          # Count existing tags matching this major.minor to auto-increment patch
          PATCH=$(git tag -l "v${BASE}.*" | wc -l | tr -d ' ')
          VERSION="v${BASE}.${PATCH}"
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "Deploying version: ${VERSION} (${SHORT_SHA})"

      - name: Build binary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w -X main.version=${VERSION}" -trimpath -o workshop ./cmd/server
        env:
          CGO_ENABLED: "0"
          GOOS: linux
          GOARCH: amd64

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Backup database
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key"
          VPS_USER="${{ secrets.VPS_USER }}"
          VPS_HOST="${{ secrets.VPS_HOST }}"
          DEPLOY_DIR="/opt/workshop"
          BACKUP_DIR="${DEPLOY_DIR}/backups"

          echo "=== Creating pre-deploy database backup ==="
          ssh $SSH_OPTS ${VPS_USER}@${VPS_HOST} << 'ENDSSH'
            # Ensure sqlite3 is available for backup
            if ! command -v sqlite3 &>/dev/null; then
              echo "Installing sqlite3..."
              sudo apt-get update -qq && sudo apt-get install -y -qq sqlite3
            fi
            set -e
            BACKUP_DIR="/opt/workshop/backups"
            DB_PATH="/opt/workshop/workshop.db"

            # Create backups directory if it doesn't exist
            sudo mkdir -p "$BACKUP_DIR"
            sudo chown workshop:workshop "$BACKUP_DIR"

            # Only backup if database exists
            if [ -f "$DB_PATH" ]; then
              TIMESTAMP=$(date +%Y%m%d-%H%M%S)
              BACKUP_FILE="${BACKUP_DIR}/workshop-pre-deploy-${TIMESTAMP}.db"
              echo "Backing up to ${BACKUP_FILE}"
              sudo -u workshop sqlite3 "$DB_PATH" ".backup ${BACKUP_FILE}"
              echo "Backup complete: $(du -h ${BACKUP_FILE} | cut -f1)"

              # Prune old backups: keep last 5 + anything less than 30 days old
              cd "$BACKUP_DIR"
              # Get all backup files sorted by time (newest first)
              ALL_BACKUPS=$(ls -t workshop-pre-deploy-*.db 2>/dev/null || true)
              COUNT=0
              for f in $ALL_BACKUPS; do
                COUNT=$((COUNT + 1))
                # Keep the 5 most recent unconditionally
                if [ $COUNT -le 5 ]; then
                  continue
                fi
                # Keep if less than 30 days old
                if [ $(find "$f" -mtime -30 -print 2>/dev/null | wc -l) -gt 0 ]; then
                  continue
                fi
                # Delete old backup
                echo "Pruning old backup: $f"
                rm -f "$f"
              done
            else
              echo "No database file found — skipping backup (first deploy)"
            fi
          ENDSSH

      - name: Deploy to VPS
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key"
          VPS_USER="${{ secrets.VPS_USER }}"
          VPS_HOST="${{ secrets.VPS_HOST }}"
          DEPLOY_DIR="/opt/workshop"

          echo "=== Uploading binary ==="
          rsync -avz -e "ssh $SSH_OPTS" \
            workshop \
            ${VPS_USER}@${VPS_HOST}:${DEPLOY_DIR}/workshop.new

          echo "=== Uploading static files ==="
          rsync -avz --delete -e "ssh $SSH_OPTS" \
            static/ \
            ${VPS_USER}@${VPS_HOST}:${DEPLOY_DIR}/static/

          echo "=== Uploading templates ==="
          rsync -avz --delete -e "ssh $SSH_OPTS" \
            internal/adapters/http/templates/ \
            ${VPS_USER}@${VPS_HOST}:${DEPLOY_DIR}/internal/adapters/http/templates/

          echo "=== Swapping binary and restarting ==="
          ssh $SSH_OPTS ${VPS_USER}@${VPS_HOST} << 'ENDSSH'
            set -e
            cd /opt/workshop
            # Atomic swap: move new binary into place, then restart
            sudo mv workshop.new workshop
            sudo chown workshop:workshop workshop
            sudo chmod +x workshop
            sudo systemctl restart workshop
            # Wait a moment and check it started
            sleep 2
            sudo systemctl is-active workshop
            # HTTP health check — verify app actually responds
            sleep 1
            if curl -sf http://127.0.0.1:8080/login > /dev/null 2>&1; then
              echo "Deploy complete! Health check passed."
            else
              echo "WARNING: Service is active but HTTP health check failed!"
              sudo journalctl -u workshop -n 20 --no-pager
              exit 1
            fi
          ENDSSH

      - name: Create release tag
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SHORT_SHA="${{ steps.version.outputs.short_sha }}"
          SCHEMA_VERSION=$(grep -oP 'version: \K[0-9]+' internal/adapters/storage/db.go | tail -1)
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")

          # Build changelog
          if [ "$PREV_TAG" = "none" ]; then
            CHANGELOG="Initial release"
          else
            CHANGELOG=$(git log ${PREV_TAG}..HEAD --oneline --no-decorate)
          fi

          BODY=$(cat <<EOF
          ## ${VERSION}

          **Commit:** ${SHORT_SHA}
          **Schema version:** ${SCHEMA_VERSION}
          **Deployed:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

          ### Changes since ${PREV_TAG}
          ${CHANGELOG}

          ### Rollback
          To roll back to the previous version, see [DEPLOY.md](deploy/DEPLOY.md#rollback).
          EOF
          )

          if git rev-parse "${VERSION}" >/dev/null 2>&1; then
            echo "Tag ${VERSION} already exists — skipping tag creation"
          else
            git tag -a "${VERSION}" -m "Release ${VERSION} (schema: ${SCHEMA_VERSION})"
            git push origin "${VERSION}"
          fi
          gh release create "${VERSION}" --title "${VERSION}" --notes "${BODY}" 2>/dev/null \
            || echo "Release ${VERSION} already exists — skipping"
